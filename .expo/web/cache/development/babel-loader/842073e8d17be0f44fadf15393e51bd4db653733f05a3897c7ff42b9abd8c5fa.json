{"ast":null,"code":"\"use strict\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nconst _excluded = [\"numberOfPointers\", \"direction\"];\nimport Hammer from '@egjs/hammerjs';\nimport { Direction } from './constants';\nimport { GesturePropError } from './Errors';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isnan } from './utils';\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n  onGestureActivated(event) {\n    this.sendEvent(Object.assign({}, event, {\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true\n    }));\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent(Object.assign({}, event, {\n      eventType: Hammer.INPUT_END,\n      isFinal: true\n    }));\n  }\n  onRawEvent(ev) {\n    super.onRawEvent(ev);\n    if (this.hasGestureFailed) {\n      return;\n    }\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      const gesture = this.hammer.get(this.name);\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n  getHammerConfig() {\n    return {\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection()\n    };\n  }\n  getTargetDirections(direction) {\n    const directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    }\n    return directions;\n  }\n  getDirection() {\n    const {\n      direction\n    } = this.getConfig();\n    let directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    directions = [...new Set(directions)];\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n  isGestureEnabledForEvent({\n    numberOfPointers\n  }, _recognizer, {\n    maxPointers: pointerLength\n  }) {\n    const validPointerCount = pointerLength === numberOfPointers;\n    if (!validPointerCount && this.isGestureRunning) {\n      return {\n        failed: true\n      };\n    }\n    return {\n      success: validPointerCount\n    };\n  }\n  updateGestureConfig(_ref) {\n    let {\n        numberOfPointers = 1,\n        direction\n      } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded);\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n    return super.updateGestureConfig(Object.assign({\n      numberOfPointers,\n      direction\n    }, props));\n  }\n}\nexport default FlingGestureHandler;","map":{"version":3,"names":["Hammer","Direction","GesturePropError","DraggingGestureHandler","isnan","FlingGestureHandler","name","NativeGestureClass","Swipe","onGestureActivated","event","sendEvent","Object","assign","eventType","INPUT_MOVE","isFinal","isFirst","isGestureRunning","hasGestureFailed","INPUT_END","onRawEvent","ev","setTimeout","cancelEvent","gesture","hammer","get","options","enable","onStart","getHammerConfig","pointers","config","numberOfPointers","direction","getDirection","getTargetDirections","directions","RIGHT","push","DIRECTION_RIGHT","LEFT","DIRECTION_LEFT","UP","DIRECTION_UP","DOWN","DIRECTION_DOWN","getConfig","DIRECTION_HORIZONTAL","DIRECTION_VERTICAL","Set","length","DIRECTION_NONE","DIRECTION_ALL","isGestureEnabledForEvent","_recognizer","maxPointers","pointerLength","validPointerCount","failed","success","updateGestureConfig","_ref","props","_objectWithoutPropertiesLoose","_excluded"],"sources":["C:\\Users\\prana\\OneDrive\\Desktop\\civic-reporter-sih\\frontend\\node_modules\\react-native-gesture-handler\\src\\web_hammer\\FlingGestureHandler.ts"],"sourcesContent":["/* eslint-disable @eslint-community/eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport Hammer from '@egjs/hammerjs';\n\nimport { Direction } from './constants';\nimport { GesturePropError } from './Errors';\nimport DraggingGestureHandler from './DraggingGestureHandler';\nimport { isnan } from './utils';\nimport { HammerInputExt } from './GestureHandler';\n\nclass FlingGestureHandler extends DraggingGestureHandler {\n  get name() {\n    return 'swipe';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Swipe;\n  }\n\n  onGestureActivated(event: HammerInputExt) {\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_MOVE,\n      isFinal: false,\n      isFirst: true,\n    });\n    this.isGestureRunning = false;\n    this.hasGestureFailed = false;\n    this.sendEvent({\n      ...event,\n      eventType: Hammer.INPUT_END,\n      isFinal: true,\n    });\n  }\n\n  onRawEvent(ev: HammerInputExt) {\n    super.onRawEvent(ev);\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      setTimeout(() => {\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer!.get(this.name);\n      // @ts-ignore FIXME(TS)\n      if (gesture.options.enable(gesture, ev)) {\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      // @ts-ignore FIXME(TS)\n      pointers: this.config.numberOfPointers,\n      direction: this.getDirection(),\n    };\n  }\n\n  getTargetDirections(direction: number) {\n    const directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_RIGHT);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_LEFT);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_UP);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_DOWN);\n    }\n    // const hammerDirection = directions.reduce((a, b) => a | b, 0);\n    return directions;\n  }\n\n  getDirection() {\n    // @ts-ignore FIXME(TS)\n    const { direction } = this.getConfig();\n\n    let directions = [];\n    if (direction & Direction.RIGHT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.LEFT) {\n      directions.push(Hammer.DIRECTION_HORIZONTAL);\n    }\n    if (direction & Direction.UP) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    if (direction & Direction.DOWN) {\n      directions.push(Hammer.DIRECTION_VERTICAL);\n    }\n    directions = [...new Set(directions)];\n\n    if (directions.length === 0) return Hammer.DIRECTION_NONE;\n    if (directions.length === 1) return directions[0];\n    return Hammer.DIRECTION_ALL;\n  }\n\n  isGestureEnabledForEvent(\n    { numberOfPointers }: any,\n    _recognizer: any,\n    { maxPointers: pointerLength }: any\n  ) {\n    const validPointerCount = pointerLength === numberOfPointers;\n    if (!validPointerCount && this.isGestureRunning) {\n      return { failed: true };\n    }\n    return { success: validPointerCount };\n  }\n\n  updateGestureConfig({ numberOfPointers = 1, direction, ...props }: any) {\n    if (isnan(direction) || typeof direction !== 'number') {\n      throw new GesturePropError('direction', direction, 'number');\n    }\n    return super.updateGestureConfig({\n      numberOfPointers,\n      direction,\n      ...props,\n    });\n  }\n}\n\nexport default FlingGestureHandler;\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}