{"ast":null,"code":"'use strict';\n\nimport { cssKeyframesRegistry, CSSKeyframesRuleImpl } from \"../keyframes/index.js\";\nimport { createSingleCSSAnimationProperties, getAnimationSettingsUpdates, normalizeSingleCSSAnimationSettings } from \"../normalization/index.js\";\nimport { applyCSSAnimations, unregisterCSSAnimations } from \"../proxy.js\";\nexport default class CSSAnimationsManager {\n  attachedAnimations = [];\n  constructor(shadowNodeWrapper, viewName, viewTag) {\n    this.shadowNodeWrapper = shadowNodeWrapper;\n    this.viewName = viewName;\n    this.viewTag = viewTag;\n  }\n  update(animationProperties) {\n    if (!animationProperties) {\n      this.detach();\n      return;\n    }\n    const processedAnimations = this.processAnimations(animationProperties);\n    this.registerKeyframesUsage(processedAnimations);\n    const animationUpdates = this.getAnimationUpdates(processedAnimations);\n    this.attachedAnimations = processedAnimations;\n    if (animationUpdates) {\n      if (animationUpdates.animationNames && animationUpdates.animationNames.length === 0) {\n        this.detach();\n        return;\n      }\n      applyCSSAnimations(this.shadowNodeWrapper, animationUpdates);\n    }\n  }\n  unmountCleanup() {\n    this.unregisterKeyframesUsage();\n  }\n  detach() {\n    if (this.attachedAnimations.length > 0) {\n      unregisterCSSAnimations(this.viewTag);\n      this.unregisterKeyframesUsage();\n      this.attachedAnimations = [];\n    }\n  }\n  registerKeyframesUsage(processedAnimations) {\n    const newAnimationNames = new Set();\n    processedAnimations.forEach(({\n      keyframesRule\n    }) => {\n      cssKeyframesRegistry.add(keyframesRule, this.viewName, this.viewTag);\n      newAnimationNames.add(keyframesRule.name);\n    });\n    this.attachedAnimations.forEach(({\n      keyframesRule: {\n        name\n      }\n    }) => {\n      if (!newAnimationNames.has(name)) {\n        cssKeyframesRegistry.remove(name, this.viewName, this.viewTag);\n      }\n    });\n  }\n  unregisterKeyframesUsage() {\n    this.attachedAnimations.forEach(({\n      keyframesRule: {\n        name\n      }\n    }) => {\n      cssKeyframesRegistry.remove(name, this.viewName, this.viewTag);\n    });\n  }\n  processAnimations(animationProperties) {\n    const singleAnimationPropertiesArray = createSingleCSSAnimationProperties(animationProperties);\n    const processedAnimations = singleAnimationPropertiesArray.map(properties => {\n      const keyframes = properties.animationName;\n      let keyframesRule;\n      if (keyframes instanceof CSSKeyframesRuleImpl) {\n        keyframesRule = keyframes;\n      } else {\n        const cssText = JSON.stringify(keyframes);\n        keyframesRule = cssKeyframesRegistry.get(cssText) ?? new CSSKeyframesRuleImpl(keyframes, cssText);\n      }\n      return {\n        normalizedSettings: normalizeSingleCSSAnimationSettings(properties),\n        keyframesRule\n      };\n    });\n    return processedAnimations;\n  }\n  buildAnimationsMap(animations) {\n    return animations.reduceRight((acc, animation) => {\n      const name = animation.keyframesRule.name;\n      if (!acc[name]) {\n        acc[name] = [animation];\n      } else {\n        acc[name].push(animation);\n      }\n      return acc;\n    }, {});\n  }\n  getAnimationUpdates(processedAnimations) {\n    const newAnimationSettings = {};\n    const settingsUpdates = {};\n    let animationsArrayChanged = this.attachedAnimations.length !== processedAnimations.length;\n    let hasNewAnimations = false;\n    let hasSettingsUpdates = false;\n    const oldAnimations = this.buildAnimationsMap(this.attachedAnimations);\n    processedAnimations.forEach(({\n      keyframesRule,\n      normalizedSettings\n    }, i) => {\n      const oldAnimation = oldAnimations[keyframesRule.name]?.pop();\n      if (!oldAnimation) {\n        hasNewAnimations = true;\n        animationsArrayChanged = true;\n        newAnimationSettings[i] = normalizedSettings;\n        return;\n      }\n      const updates = getAnimationSettingsUpdates(oldAnimation.normalizedSettings, normalizedSettings);\n      if (Object.keys(updates).length > 0) {\n        hasSettingsUpdates = true;\n        settingsUpdates[i] = updates;\n      }\n      if (oldAnimation.keyframesRule.name !== keyframesRule.name) {\n        animationsArrayChanged = true;\n      }\n    });\n    const result = {};\n    if (animationsArrayChanged) {\n      result.animationNames = processedAnimations.map(({\n        keyframesRule\n      }) => keyframesRule.name);\n    }\n    if (hasNewAnimations) {\n      result.newAnimationSettings = newAnimationSettings;\n    }\n    if (hasSettingsUpdates) {\n      result.settingsUpdates = settingsUpdates;\n    }\n    if (hasNewAnimations || hasSettingsUpdates || animationsArrayChanged) {\n      return result;\n    }\n    return null;\n  }\n}","map":{"version":3,"names":["cssKeyframesRegistry","CSSKeyframesRuleImpl","createSingleCSSAnimationProperties","getAnimationSettingsUpdates","normalizeSingleCSSAnimationSettings","applyCSSAnimations","unregisterCSSAnimations","CSSAnimationsManager","attachedAnimations","constructor","shadowNodeWrapper","viewName","viewTag","update","animationProperties","detach","processedAnimations","processAnimations","registerKeyframesUsage","animationUpdates","getAnimationUpdates","animationNames","length","unmountCleanup","unregisterKeyframesUsage","newAnimationNames","Set","forEach","keyframesRule","add","name","has","remove","singleAnimationPropertiesArray","map","properties","keyframes","animationName","cssText","JSON","stringify","get","normalizedSettings","buildAnimationsMap","animations","reduceRight","acc","animation","push","newAnimationSettings","settingsUpdates","animationsArrayChanged","hasNewAnimations","hasSettingsUpdates","oldAnimations","i","oldAnimation","pop","updates","Object","keys","result"],"sources":["C:\\Users\\prana\\OneDrive\\Desktop\\civic-reporter-sih\\frontend\\node_modules\\react-native-reanimated\\src\\css\\native\\managers\\CSSAnimationsManager.ts"],"sourcesContent":["'use strict';\nimport type { ShadowNodeWrapper } from '../../../commonTypes';\nimport type {\n  CSSAnimationKeyframes,\n  ExistingCSSAnimationProperties,\n  ICSSAnimationsManager,\n} from '../../types';\nimport { cssKeyframesRegistry, CSSKeyframesRuleImpl } from '../keyframes';\nimport {\n  createSingleCSSAnimationProperties,\n  getAnimationSettingsUpdates,\n  normalizeSingleCSSAnimationSettings,\n} from '../normalization';\nimport { applyCSSAnimations, unregisterCSSAnimations } from '../proxy';\nimport type {\n  CSSAnimationUpdates,\n  NormalizedSingleCSSAnimationSettings,\n} from '../types';\n\ntype ProcessedAnimation = {\n  normalizedSettings: NormalizedSingleCSSAnimationSettings;\n  keyframesRule: CSSKeyframesRuleImpl;\n};\n\nexport default class CSSAnimationsManager implements ICSSAnimationsManager {\n  private readonly shadowNodeWrapper: ShadowNodeWrapper;\n  private readonly viewName: string;\n  private readonly viewTag: number;\n\n  private attachedAnimations: ProcessedAnimation[] = [];\n\n  constructor(\n    shadowNodeWrapper: ShadowNodeWrapper,\n    viewName: string,\n    viewTag: number\n  ) {\n    this.shadowNodeWrapper = shadowNodeWrapper;\n    this.viewName = viewName;\n    this.viewTag = viewTag;\n  }\n\n  update(animationProperties: ExistingCSSAnimationProperties | null): void {\n    if (!animationProperties) {\n      this.detach();\n      return;\n    }\n\n    const processedAnimations = this.processAnimations(animationProperties);\n    this.registerKeyframesUsage(processedAnimations);\n\n    const animationUpdates = this.getAnimationUpdates(processedAnimations);\n    this.attachedAnimations = processedAnimations;\n\n    if (animationUpdates) {\n      if (\n        animationUpdates.animationNames &&\n        animationUpdates.animationNames.length === 0\n      ) {\n        this.detach();\n        return;\n      }\n\n      applyCSSAnimations(this.shadowNodeWrapper, animationUpdates);\n    }\n  }\n\n  unmountCleanup(): void {\n    this.unregisterKeyframesUsage();\n  }\n\n  private detach() {\n    if (this.attachedAnimations.length > 0) {\n      unregisterCSSAnimations(this.viewTag);\n      this.unregisterKeyframesUsage();\n      this.attachedAnimations = [];\n    }\n  }\n\n  private registerKeyframesUsage(processedAnimations: ProcessedAnimation[]) {\n    const newAnimationNames = new Set();\n\n    // Register keyframes for all new animations\n    processedAnimations.forEach(({ keyframesRule }) => {\n      cssKeyframesRegistry.add(keyframesRule, this.viewName, this.viewTag);\n      newAnimationNames.add(keyframesRule.name);\n    });\n\n    // Unregister keyframes for all old animations that are no longer attached\n    // to the view\n    this.attachedAnimations.forEach(({ keyframesRule: { name } }) => {\n      if (!newAnimationNames.has(name)) {\n        cssKeyframesRegistry.remove(name, this.viewName, this.viewTag);\n      }\n    });\n  }\n\n  private unregisterKeyframesUsage() {\n    // Unregister keyframes usage by the view (it is necessary to clean up\n    // keyframes from the CPP registry once all views that use them are unmounted)\n    this.attachedAnimations.forEach(({ keyframesRule: { name } }) => {\n      cssKeyframesRegistry.remove(name, this.viewName, this.viewTag);\n    });\n  }\n\n  private processAnimations(\n    animationProperties: ExistingCSSAnimationProperties\n  ): ProcessedAnimation[] {\n    const singleAnimationPropertiesArray =\n      createSingleCSSAnimationProperties(animationProperties);\n\n    const processedAnimations = singleAnimationPropertiesArray.map(\n      (properties) => {\n        const keyframes = properties.animationName;\n        let keyframesRule: CSSKeyframesRuleImpl;\n\n        if (keyframes instanceof CSSKeyframesRuleImpl) {\n          // If the instance of the CSSKeyframesRule class was passed, we can just compare\n          // references to the instance (css.keyframes() call should be memoized in order\n          // to preserve the same animation. If used inline, it will restart the animation\n          // on every component re-render)\n          keyframesRule = keyframes;\n        } else {\n          // If the keyframes are not an instance of the CSSKeyframesRule class (e.g. someone\n          // passes a keyframes object inline in the component's style without using css.keyframes()\n          // function), we don't want to restart the animation on every component re-render.\n          // In this case, we need to check if the animation with the same keyframes is already\n          // registered in the registry. If it is, we can just use the existing keyframes rule.\n          // Otherwise, we need to create a new keyframes rule.\n          const cssText = JSON.stringify(keyframes);\n          keyframesRule =\n            cssKeyframesRegistry.get(cssText) ??\n            new CSSKeyframesRuleImpl(\n              keyframes as CSSAnimationKeyframes,\n              cssText\n            );\n        }\n\n        return {\n          normalizedSettings: normalizeSingleCSSAnimationSettings(properties),\n          keyframesRule,\n        };\n      }\n    );\n\n    return processedAnimations;\n  }\n\n  private buildAnimationsMap(animations: ProcessedAnimation[]) {\n    // Iterate over attached animations from last to first for faster pop from\n    // the end of the array when removing used animations\n    return animations.reduceRight<Record<string, ProcessedAnimation[]>>(\n      (acc, animation) => {\n        const name = animation.keyframesRule.name;\n        if (!acc[name]) {\n          acc[name] = [animation];\n        } else {\n          acc[name].push(animation);\n        }\n        return acc;\n      },\n      {}\n    );\n  }\n\n  private getAnimationUpdates(\n    processedAnimations: ProcessedAnimation[]\n  ): CSSAnimationUpdates | null {\n    const newAnimationSettings: Record<\n      number,\n      NormalizedSingleCSSAnimationSettings\n    > = {};\n    const settingsUpdates: Record<\n      number,\n      Partial<NormalizedSingleCSSAnimationSettings>\n    > = {};\n\n    let animationsArrayChanged =\n      this.attachedAnimations.length !== processedAnimations.length;\n    let hasNewAnimations = false;\n    let hasSettingsUpdates = false;\n\n    const oldAnimations = this.buildAnimationsMap(this.attachedAnimations);\n\n    processedAnimations.forEach(({ keyframesRule, normalizedSettings }, i) => {\n      const oldAnimation = oldAnimations[keyframesRule.name]?.pop();\n\n      if (!oldAnimation) {\n        hasNewAnimations = true;\n        animationsArrayChanged = true;\n        newAnimationSettings[i] = normalizedSettings;\n        return;\n      }\n\n      const updates = getAnimationSettingsUpdates(\n        oldAnimation.normalizedSettings,\n        normalizedSettings\n      );\n\n      if (Object.keys(updates).length > 0) {\n        hasSettingsUpdates = true;\n        settingsUpdates[i] = updates;\n      }\n\n      if (oldAnimation.keyframesRule.name !== keyframesRule.name) {\n        animationsArrayChanged = true;\n      }\n    });\n\n    const result: CSSAnimationUpdates = {};\n    if (animationsArrayChanged) {\n      result.animationNames = processedAnimations.map(\n        ({ keyframesRule }) => keyframesRule.name\n      );\n    }\n    if (hasNewAnimations) {\n      result.newAnimationSettings = newAnimationSettings;\n    }\n    if (hasSettingsUpdates) {\n      result.settingsUpdates = settingsUpdates;\n    }\n\n    if (hasNewAnimations || hasSettingsUpdates || animationsArrayChanged) {\n      return result;\n    }\n\n    return null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}