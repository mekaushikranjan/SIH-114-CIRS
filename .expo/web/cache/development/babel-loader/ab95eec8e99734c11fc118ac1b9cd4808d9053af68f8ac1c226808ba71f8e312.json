{"ast":null,"code":"\"use strict\";\n\nimport { State } from '../../State';\nimport { DEFAULT_TOUCH_SLOP } from '../constants';\nimport GestureHandler from './GestureHandler';\nimport ScaleGestureDetector from '../detectors/ScaleGestureDetector';\nexport default class PinchGestureHandler extends GestureHandler {\n  scale = 1;\n  velocity = 0;\n  startingSpan = 0;\n  spanSlop = DEFAULT_TOUCH_SLOP;\n  scaleDetectorListener = {\n    onScaleBegin: detector => {\n      this.startingSpan = detector.currentSpan;\n      return true;\n    },\n    onScale: detector => {\n      const prevScaleFactor = this.scale;\n      this.scale *= detector.calculateScaleFactor(this.tracker.trackedPointersCount);\n      const delta = detector.timeDelta;\n      if (delta > 0) {\n        this.velocity = (this.scale - prevScaleFactor) / delta;\n      }\n      if (Math.abs(this.startingSpan - detector.currentSpan) >= this.spanSlop && this.state === State.BEGAN) {\n        this.activate();\n      }\n      return true;\n    },\n    onScaleEnd: _detector => {}\n  };\n  scaleGestureDetector = new ScaleGestureDetector(this.scaleDetectorListener);\n  init(ref, propsRef) {\n    super.init(ref, propsRef);\n    this.shouldCancelWhenOutside = false;\n  }\n  transformNativeEvent() {\n    return {\n      focalX: this.scaleGestureDetector.focusX,\n      focalY: this.scaleGestureDetector.focusY,\n      velocity: this.velocity,\n      scale: this.scale\n    };\n  }\n  onPointerDown(event) {\n    this.tracker.addToTracker(event);\n    super.onPointerDown(event);\n    this.tryToSendTouchEvent(event);\n  }\n  onPointerAdd(event) {\n    this.tracker.addToTracker(event);\n    super.onPointerAdd(event);\n    this.tryBegin();\n    this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n  }\n  onPointerUp(event) {\n    super.onPointerUp(event);\n    this.tracker.removeFromTracker(event.pointerId);\n    if (this.state !== State.ACTIVE) {\n      return;\n    }\n    this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n    if (this.state === State.ACTIVE) {\n      this.end();\n    } else {\n      this.fail();\n    }\n  }\n  onPointerRemove(event) {\n    super.onPointerRemove(event);\n    this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n    this.tracker.removeFromTracker(event.pointerId);\n    if (this.state === State.ACTIVE && this.tracker.trackedPointersCount < 2) {\n      this.end();\n    }\n  }\n  onPointerMove(event) {\n    if (this.tracker.trackedPointersCount < 2) {\n      return;\n    }\n    this.tracker.track(event);\n    this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n    super.onPointerMove(event);\n  }\n  onPointerOutOfBounds(event) {\n    if (this.tracker.trackedPointersCount < 2) {\n      return;\n    }\n    this.tracker.track(event);\n    this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n    super.onPointerOutOfBounds(event);\n  }\n  tryBegin() {\n    if (this.state !== State.UNDETERMINED) {\n      return;\n    }\n    this.resetProgress();\n    this.begin();\n  }\n  activate(force) {\n    if (this.state !== State.ACTIVE) {\n      this.resetProgress();\n    }\n    super.activate(force);\n  }\n  onReset() {\n    this.resetProgress();\n  }\n  resetProgress() {\n    if (this.state === State.ACTIVE) {\n      return;\n    }\n    this.velocity = 0;\n    this.scale = 1;\n  }\n}","map":{"version":3,"names":["State","DEFAULT_TOUCH_SLOP","GestureHandler","ScaleGestureDetector","PinchGestureHandler","scale","velocity","startingSpan","spanSlop","scaleDetectorListener","onScaleBegin","detector","currentSpan","onScale","prevScaleFactor","calculateScaleFactor","tracker","trackedPointersCount","delta","timeDelta","Math","abs","state","BEGAN","activate","onScaleEnd","_detector","scaleGestureDetector","init","ref","propsRef","shouldCancelWhenOutside","transformNativeEvent","focalX","focusX","focalY","focusY","onPointerDown","event","addToTracker","tryToSendTouchEvent","onPointerAdd","tryBegin","onTouchEvent","onPointerUp","removeFromTracker","pointerId","ACTIVE","end","fail","onPointerRemove","onPointerMove","track","onPointerOutOfBounds","UNDETERMINED","resetProgress","begin","force","onReset"],"sources":["C:\\Users\\prana\\OneDrive\\Desktop\\civic-reporter-sih\\frontend\\node_modules\\react-native-gesture-handler\\src\\web\\handlers\\PinchGestureHandler.ts"],"sourcesContent":["import { State } from '../../State';\nimport { DEFAULT_TOUCH_SLOP } from '../constants';\nimport { AdaptedEvent } from '../interfaces';\n\nimport GestureHandler from './GestureHandler';\nimport ScaleGestureDetector, {\n  ScaleGestureListener,\n} from '../detectors/ScaleGestureDetector';\n\nexport default class PinchGestureHandler extends GestureHandler {\n  private scale = 1;\n  private velocity = 0;\n\n  private startingSpan = 0;\n  private spanSlop = DEFAULT_TOUCH_SLOP;\n\n  private scaleDetectorListener: ScaleGestureListener = {\n    onScaleBegin: (detector: ScaleGestureDetector): boolean => {\n      this.startingSpan = detector.currentSpan;\n      return true;\n    },\n    onScale: (detector: ScaleGestureDetector): boolean => {\n      const prevScaleFactor: number = this.scale;\n      this.scale *= detector.calculateScaleFactor(\n        this.tracker.trackedPointersCount\n      );\n\n      const delta = detector.timeDelta;\n      if (delta > 0) {\n        this.velocity = (this.scale - prevScaleFactor) / delta;\n      }\n\n      if (\n        Math.abs(this.startingSpan - detector.currentSpan) >= this.spanSlop &&\n        this.state === State.BEGAN\n      ) {\n        this.activate();\n      }\n      return true;\n    },\n    onScaleEnd: (\n      _detector: ScaleGestureDetector\n      // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ): void => {},\n  };\n\n  private scaleGestureDetector: ScaleGestureDetector = new ScaleGestureDetector(\n    this.scaleDetectorListener\n  );\n\n  public init(ref: number, propsRef: React.RefObject<unknown>) {\n    super.init(ref, propsRef);\n\n    this.shouldCancelWhenOutside = false;\n  }\n\n  protected transformNativeEvent() {\n    return {\n      focalX: this.scaleGestureDetector.focusX,\n      focalY: this.scaleGestureDetector.focusY,\n      velocity: this.velocity,\n      scale: this.scale,\n    };\n  }\n\n  protected onPointerDown(event: AdaptedEvent): void {\n    this.tracker.addToTracker(event);\n    super.onPointerDown(event);\n\n    this.tryToSendTouchEvent(event);\n  }\n\n  protected onPointerAdd(event: AdaptedEvent): void {\n    this.tracker.addToTracker(event);\n    super.onPointerAdd(event);\n    this.tryBegin();\n    this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n  }\n\n  protected onPointerUp(event: AdaptedEvent): void {\n    super.onPointerUp(event);\n    this.tracker.removeFromTracker(event.pointerId);\n    if (this.state !== State.ACTIVE) {\n      return;\n    }\n    this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n\n    if (this.state === State.ACTIVE) {\n      this.end();\n    } else {\n      this.fail();\n    }\n  }\n\n  protected onPointerRemove(event: AdaptedEvent): void {\n    super.onPointerRemove(event);\n    this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n    this.tracker.removeFromTracker(event.pointerId);\n\n    if (this.state === State.ACTIVE && this.tracker.trackedPointersCount < 2) {\n      this.end();\n    }\n  }\n\n  protected onPointerMove(event: AdaptedEvent): void {\n    if (this.tracker.trackedPointersCount < 2) {\n      return;\n    }\n    this.tracker.track(event);\n\n    this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n    super.onPointerMove(event);\n  }\n  protected onPointerOutOfBounds(event: AdaptedEvent): void {\n    if (this.tracker.trackedPointersCount < 2) {\n      return;\n    }\n    this.tracker.track(event);\n\n    this.scaleGestureDetector.onTouchEvent(event, this.tracker);\n    super.onPointerOutOfBounds(event);\n  }\n\n  private tryBegin(): void {\n    if (this.state !== State.UNDETERMINED) {\n      return;\n    }\n\n    this.resetProgress();\n    this.begin();\n  }\n\n  public activate(force?: boolean): void {\n    if (this.state !== State.ACTIVE) {\n      this.resetProgress();\n    }\n\n    super.activate(force);\n  }\n\n  protected onReset(): void {\n    this.resetProgress();\n  }\n\n  protected resetProgress(): void {\n    if (this.state === State.ACTIVE) {\n      return;\n    }\n    this.velocity = 0;\n    this.scale = 1;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}