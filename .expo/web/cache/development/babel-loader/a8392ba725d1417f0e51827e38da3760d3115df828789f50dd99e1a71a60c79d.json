{"ast":null,"code":"import * as Location from 'expo-location';\nimport Alert from \"react-native-web/dist/exports/Alert\";\nclass LocationService {\n  watchId = null;\n  lastKnownLocation = null;\n  async requestLocationPermission() {\n    try {\n      const {\n        status,\n        canAskAgain\n      } = await Location.requestForegroundPermissionsAsync();\n      return {\n        granted: status === 'granted',\n        canAskAgain,\n        status\n      };\n    } catch (error) {\n      console.error('Location permission error:', error);\n      return {\n        granted: false,\n        canAskAgain: false,\n        status: Location.PermissionStatus.DENIED\n      };\n    }\n  }\n  async getCurrentLocation(highAccuracy = true) {\n    try {\n      const permission = await this.requestLocationPermission();\n      if (!permission.granted) {\n        Alert.alert('Location Permission Required', 'This app needs location access to track work locations and verify check-ins.', [{\n          text: 'Cancel',\n          style: 'cancel'\n        }, {\n          text: 'Settings',\n          onPress: () => Location.requestForegroundPermissionsAsync()\n        }]);\n        return null;\n      }\n      const location = await Location.getCurrentPositionAsync({\n        accuracy: highAccuracy ? Location.Accuracy.High : Location.Accuracy.Balanced\n      });\n      const locationData = {\n        latitude: location.coords.latitude,\n        longitude: location.coords.longitude,\n        accuracy: location.coords.accuracy || undefined,\n        altitude: location.coords.altitude || undefined,\n        heading: location.coords.heading || undefined,\n        speed: location.coords.speed || undefined,\n        timestamp: new Date().toISOString()\n      };\n      try {\n        const address = await this.reverseGeocode(locationData.latitude, locationData.longitude);\n        locationData.address = address || undefined;\n      } catch (geocodeError) {\n        console.log('Geocoding failed:', geocodeError);\n      }\n      this.lastKnownLocation = locationData;\n      return locationData;\n    } catch (error) {\n      console.error('Get location error:', error);\n      Alert.alert('Location Error', 'Failed to get current location. Please try again.');\n      return null;\n    }\n  }\n  async startLocationTracking(callback, options) {\n    try {\n      const permission = await this.requestLocationPermission();\n      if (!permission.granted) {\n        return false;\n      }\n      if (this.watchId) {\n        this.stopLocationTracking();\n      }\n      this.watchId = await Location.watchPositionAsync({\n        accuracy: options?.accuracy || Location.Accuracy.High,\n        timeInterval: options?.timeInterval || 10000,\n        distanceInterval: options?.distanceInterval || 10\n      }, location => {\n        const locationData = {\n          latitude: location.coords.latitude,\n          longitude: location.coords.longitude,\n          accuracy: location.coords.accuracy || undefined,\n          altitude: location.coords.altitude || undefined,\n          heading: location.coords.heading || undefined,\n          speed: location.coords.speed || undefined,\n          timestamp: new Date().toISOString()\n        };\n        this.lastKnownLocation = locationData;\n        callback(locationData);\n      });\n      return true;\n    } catch (error) {\n      console.error('Start location tracking error:', error);\n      return false;\n    }\n  }\n  stopLocationTracking() {\n    if (this.watchId) {\n      this.watchId.remove();\n      this.watchId = null;\n    }\n  }\n  async reverseGeocode(latitude, longitude) {\n    try {\n      const addresses = await Location.reverseGeocodeAsync({\n        latitude,\n        longitude\n      });\n      if (addresses.length > 0) {\n        const address = addresses[0];\n        const parts = [address.name, address.street, address.city, address.region, address.postalCode, address.country].filter(Boolean);\n        return parts.join(', ');\n      }\n      return null;\n    } catch (error) {\n      console.error('Reverse geocode error:', error);\n      return null;\n    }\n  }\n  calculateDistance(lat1, lon1, lat2, lon2) {\n    const R = 6371e3;\n    const φ1 = lat1 * Math.PI / 180;\n    const φ2 = lat2 * Math.PI / 180;\n    const Δφ = (lat2 - lat1) * Math.PI / 180;\n    const Δλ = (lon2 - lon1) * Math.PI / 180;\n    const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n  }\n  isWithinWorkSite(currentLat, currentLon, workSiteLat, workSiteLon, maxDistance = 100) {\n    const distance = this.calculateDistance(currentLat, currentLon, workSiteLat, workSiteLon);\n    return distance <= maxDistance;\n  }\n  getLastKnownLocation() {\n    return this.lastKnownLocation;\n  }\n  async isLocationEnabled() {\n    try {\n      return await Location.hasServicesEnabledAsync();\n    } catch (error) {\n      console.error('Check location services error:', error);\n      return false;\n    }\n  }\n  formatLocationForDisplay(location) {\n    if (location.address) {\n      return location.address;\n    }\n    return `${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}`;\n  }\n  createLocationPayload(location) {\n    return {\n      latitude: location.latitude,\n      longitude: location.longitude,\n      accuracy: location.accuracy,\n      timestamp: location.timestamp,\n      address: location.address\n    };\n  }\n  isLocationAccurate(location, maxAccuracy = 50) {\n    return !location.accuracy || location.accuracy <= maxAccuracy;\n  }\n  async getCurrentLocationWithRetry(maxRetries = 3, retryDelay = 2000) {\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        const location = await this.getCurrentLocation();\n        if (location && this.isLocationAccurate(location)) {\n          return location;\n        }\n        if (attempt < maxRetries) {\n          console.log(`Location attempt ${attempt} failed, retrying...`);\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\n        }\n      } catch (error) {\n        console.error(`Location attempt ${attempt} error:`, error);\n        if (attempt === maxRetries) {\n          throw error;\n        }\n      }\n    }\n    return null;\n  }\n  async startBackgroundLocationTracking() {\n    try {\n      const permission = await Location.requestBackgroundPermissionsAsync();\n      if (permission.status !== 'granted') {\n        Alert.alert('Background Location Required', 'To track work progress accurately, please allow background location access.', [{\n          text: 'Cancel',\n          style: 'cancel'\n        }, {\n          text: 'Settings',\n          onPress: () => Location.requestBackgroundPermissionsAsync()\n        }]);\n        return false;\n      }\n      await Location.startLocationUpdatesAsync('workTracking', {\n        accuracy: Location.Accuracy.High,\n        timeInterval: 30000,\n        distanceInterval: 20,\n        foregroundService: {\n          notificationTitle: 'Work Location Tracking',\n          notificationBody: 'Tracking your work location for progress verification.'\n        }\n      });\n      return true;\n    } catch (error) {\n      console.error('Background location tracking error:', error);\n      return false;\n    }\n  }\n  async stopBackgroundLocationTracking() {\n    try {\n      await Location.stopLocationUpdatesAsync('workTracking');\n    } catch (error) {\n      console.error('Stop background tracking error:', error);\n    }\n  }\n}\nexport const locationService = new LocationService();\nexport default locationService;","map":{"version":3,"names":["Location","Alert","LocationService","watchId","lastKnownLocation","requestLocationPermission","status","canAskAgain","requestForegroundPermissionsAsync","granted","error","console","PermissionStatus","DENIED","getCurrentLocation","highAccuracy","permission","alert","text","style","onPress","location","getCurrentPositionAsync","accuracy","Accuracy","High","Balanced","locationData","latitude","coords","longitude","undefined","altitude","heading","speed","timestamp","Date","toISOString","address","reverseGeocode","geocodeError","log","startLocationTracking","callback","options","stopLocationTracking","watchPositionAsync","timeInterval","distanceInterval","remove","addresses","reverseGeocodeAsync","length","parts","name","street","city","region","postalCode","country","filter","Boolean","join","calculateDistance","lat1","lon1","lat2","lon2","R","φ1","Math","PI","φ2","Δφ","Δλ","a","sin","cos","c","atan2","sqrt","isWithinWorkSite","currentLat","currentLon","workSiteLat","workSiteLon","maxDistance","distance","getLastKnownLocation","isLocationEnabled","hasServicesEnabledAsync","formatLocationForDisplay","toFixed","createLocationPayload","isLocationAccurate","maxAccuracy","getCurrentLocationWithRetry","maxRetries","retryDelay","attempt","Promise","resolve","setTimeout","startBackgroundLocationTracking","requestBackgroundPermissionsAsync","startLocationUpdatesAsync","foregroundService","notificationTitle","notificationBody","stopBackgroundLocationTracking","stopLocationUpdatesAsync","locationService"],"sources":["C:/Users/prana/OneDrive/Desktop/civic-reporter-sih/frontend/src/services/locationService.ts"],"sourcesContent":["import * as Location from 'expo-location';\nimport { Alert } from 'react-native';\n\nexport interface LocationData {\n  latitude: number;\n  longitude: number;\n  accuracy?: number;\n  altitude?: number;\n  heading?: number;\n  speed?: number;\n  timestamp: string;\n  address?: string;\n}\n\nexport interface LocationPermissionStatus {\n  granted: boolean;\n  canAskAgain: boolean;\n  status: Location.PermissionStatus;\n}\n\nclass LocationService {\n  private watchId: Location.LocationSubscription | null = null;\n  private lastKnownLocation: LocationData | null = null;\n\n  /**\n   * Request location permissions\n   */\n  async requestLocationPermission(): Promise<LocationPermissionStatus> {\n    try {\n      const { status, canAskAgain } = await Location.requestForegroundPermissionsAsync();\n      \n      return {\n        granted: status === 'granted',\n        canAskAgain,\n        status\n      };\n    } catch (error) {\n      console.error('Location permission error:', error);\n      return {\n        granted: false,\n        canAskAgain: false,\n        status: Location.PermissionStatus.DENIED\n      };\n    }\n  }\n\n  /**\n   * Get current location\n   */\n  async getCurrentLocation(highAccuracy: boolean = true): Promise<LocationData | null> {\n    try {\n      const permission = await this.requestLocationPermission();\n      \n      if (!permission.granted) {\n        Alert.alert(\n          'Location Permission Required',\n          'This app needs location access to track work locations and verify check-ins.',\n          [\n            { text: 'Cancel', style: 'cancel' },\n            { text: 'Settings', onPress: () => Location.requestForegroundPermissionsAsync() }\n          ]\n        );\n        return null;\n      }\n\n      const location = await Location.getCurrentPositionAsync({\n        accuracy: highAccuracy ? Location.Accuracy.High : Location.Accuracy.Balanced,\n      });\n\n      const locationData: LocationData = {\n        latitude: location.coords.latitude,\n        longitude: location.coords.longitude,\n        accuracy: location.coords.accuracy || undefined,\n        altitude: location.coords.altitude || undefined,\n        heading: location.coords.heading || undefined,\n        speed: location.coords.speed || undefined,\n        timestamp: new Date().toISOString(),\n      };\n\n      // Try to get address\n      try {\n        const address = await this.reverseGeocode(locationData.latitude, locationData.longitude);\n        locationData.address = address || undefined;\n      } catch (geocodeError) {\n        console.log('Geocoding failed:', geocodeError);\n      }\n\n      this.lastKnownLocation = locationData;\n      return locationData;\n    } catch (error) {\n      console.error('Get location error:', error);\n      Alert.alert('Location Error', 'Failed to get current location. Please try again.');\n      return null;\n    }\n  }\n\n  /**\n   * Start watching location changes\n   */\n  async startLocationTracking(\n    callback: (location: LocationData) => void,\n    options?: {\n      accuracy?: Location.Accuracy;\n      timeInterval?: number;\n      distanceInterval?: number;\n    }\n  ): Promise<boolean> {\n    try {\n      const permission = await this.requestLocationPermission();\n      \n      if (!permission.granted) {\n        return false;\n      }\n\n      // Stop existing tracking\n      if (this.watchId) {\n        this.stopLocationTracking();\n      }\n\n      this.watchId = await Location.watchPositionAsync(\n        {\n          accuracy: options?.accuracy || Location.Accuracy.High,\n          timeInterval: options?.timeInterval || 10000, // 10 seconds\n          distanceInterval: options?.distanceInterval || 10, // 10 meters\n        },\n        (location) => {\n          const locationData: LocationData = {\n            latitude: location.coords.latitude,\n            longitude: location.coords.longitude,\n            accuracy: location.coords.accuracy || undefined,\n            altitude: location.coords.altitude || undefined,\n            heading: location.coords.heading || undefined,\n            speed: location.coords.speed || undefined,\n            timestamp: new Date().toISOString(),\n          };\n\n          this.lastKnownLocation = locationData;\n          callback(locationData);\n        }\n      );\n\n      return true;\n    } catch (error) {\n      console.error('Start location tracking error:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Stop location tracking\n   */\n  stopLocationTracking(): void {\n    if (this.watchId) {\n      this.watchId.remove();\n      this.watchId = null;\n    }\n  }\n\n  /**\n   * Reverse geocode coordinates to address\n   */\n  async reverseGeocode(latitude: number, longitude: number): Promise<string | null> {\n    try {\n      const addresses = await Location.reverseGeocodeAsync({\n        latitude,\n        longitude,\n      });\n\n      if (addresses.length > 0) {\n        const address = addresses[0];\n        const parts = [\n          address.name,\n          address.street,\n          address.city,\n          address.region,\n          address.postalCode,\n          address.country\n        ].filter(Boolean);\n\n        return parts.join(', ');\n      }\n\n      return null;\n    } catch (error) {\n      console.error('Reverse geocode error:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Calculate distance between two points (in meters)\n   */\n  calculateDistance(\n    lat1: number,\n    lon1: number,\n    lat2: number,\n    lon2: number\n  ): number {\n    const R = 6371e3; // Earth's radius in meters\n    const φ1 = (lat1 * Math.PI) / 180;\n    const φ2 = (lat2 * Math.PI) / 180;\n    const Δφ = ((lat2 - lat1) * Math.PI) / 180;\n    const Δλ = ((lon2 - lon1) * Math.PI) / 180;\n\n    const a =\n      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +\n      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return R * c;\n  }\n\n  /**\n   * Check if worker is within acceptable range of work site\n   */\n  isWithinWorkSite(\n    currentLat: number,\n    currentLon: number,\n    workSiteLat: number,\n    workSiteLon: number,\n    maxDistance: number = 100 // 100 meters default\n  ): boolean {\n    const distance = this.calculateDistance(currentLat, currentLon, workSiteLat, workSiteLon);\n    return distance <= maxDistance;\n  }\n\n  /**\n   * Get last known location\n   */\n  getLastKnownLocation(): LocationData | null {\n    return this.lastKnownLocation;\n  }\n\n  /**\n   * Check if location services are enabled\n   */\n  async isLocationEnabled(): Promise<boolean> {\n    try {\n      return await Location.hasServicesEnabledAsync();\n    } catch (error) {\n      console.error('Check location services error:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Format location for display\n   */\n  formatLocationForDisplay(location: LocationData): string {\n    if (location.address) {\n      return location.address;\n    }\n    \n    return `${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}`;\n  }\n\n  /**\n   * Create location object for API calls\n   */\n  createLocationPayload(location: LocationData): any {\n    return {\n      latitude: location.latitude,\n      longitude: location.longitude,\n      accuracy: location.accuracy,\n      timestamp: location.timestamp,\n      address: location.address,\n    };\n  }\n\n  /**\n   * Validate location accuracy\n   */\n  isLocationAccurate(location: LocationData, maxAccuracy: number = 50): boolean {\n    return !location.accuracy || location.accuracy <= maxAccuracy;\n  }\n\n  /**\n   * Get location with retry mechanism\n   */\n  async getCurrentLocationWithRetry(\n    maxRetries: number = 3,\n    retryDelay: number = 2000\n  ): Promise<LocationData | null> {\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        const location = await this.getCurrentLocation();\n        if (location && this.isLocationAccurate(location)) {\n          return location;\n        }\n        \n        if (attempt < maxRetries) {\n          console.log(`Location attempt ${attempt} failed, retrying...`);\n          await new Promise(resolve => setTimeout(resolve, retryDelay));\n        }\n      } catch (error) {\n        console.error(`Location attempt ${attempt} error:`, error);\n        if (attempt === maxRetries) {\n          throw error;\n        }\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Background location tracking for work sessions\n   */\n  async startBackgroundLocationTracking(): Promise<boolean> {\n    try {\n      const permission = await Location.requestBackgroundPermissionsAsync();\n      \n      if (permission.status !== 'granted') {\n        Alert.alert(\n          'Background Location Required',\n          'To track work progress accurately, please allow background location access.',\n          [\n            { text: 'Cancel', style: 'cancel' },\n            { text: 'Settings', onPress: () => Location.requestBackgroundPermissionsAsync() }\n          ]\n        );\n        return false;\n      }\n\n      // Start background location task\n      await Location.startLocationUpdatesAsync('workTracking', {\n        accuracy: Location.Accuracy.High,\n        timeInterval: 30000, // 30 seconds\n        distanceInterval: 20, // 20 meters\n        foregroundService: {\n          notificationTitle: 'Work Location Tracking',\n          notificationBody: 'Tracking your work location for progress verification.',\n        },\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Background location tracking error:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Stop background location tracking\n   */\n  async stopBackgroundLocationTracking(): Promise<void> {\n    try {\n      await Location.stopLocationUpdatesAsync('workTracking');\n    } catch (error) {\n      console.error('Stop background tracking error:', error);\n    }\n  }\n}\n\nexport const locationService = new LocationService();\nexport default locationService;\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}