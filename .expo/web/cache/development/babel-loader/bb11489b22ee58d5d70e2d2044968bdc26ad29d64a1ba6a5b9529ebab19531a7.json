{"ast":null,"code":"import { PermissionStatus, Platform } from 'expo-modules-core';\nimport { CameraType } from './ImagePicker.types';\nimport { parseMediaTypes } from './utils';\nconst MediaTypeInput = {\n  images: 'image/*',\n  videos: 'video/mp4,video/quicktime,video/x-m4v,video/*',\n  livePhotos: ''\n};\nexport default {\n  async launchImageLibraryAsync({\n    mediaTypes = ['images'],\n    allowsMultipleSelection = false,\n    base64 = false\n  }) {\n    if (!Platform.isDOMAvailable) {\n      return {\n        canceled: true,\n        assets: null\n      };\n    }\n    return await openFileBrowserAsync({\n      mediaTypes,\n      allowsMultipleSelection,\n      base64\n    });\n  },\n  async launchCameraAsync({\n    mediaTypes = ['images'],\n    allowsMultipleSelection = false,\n    base64 = false,\n    cameraType\n  }) {\n    if (!Platform.isDOMAvailable) {\n      return {\n        canceled: true,\n        assets: null\n      };\n    }\n    return await openFileBrowserAsync({\n      mediaTypes,\n      allowsMultipleSelection,\n      capture: cameraType ?? true,\n      base64\n    });\n  },\n  async getCameraPermissionsAsync() {\n    return permissionGrantedResponse();\n  },\n  async requestCameraPermissionsAsync() {\n    return permissionGrantedResponse();\n  },\n  async getMediaLibraryPermissionsAsync(_writeOnly) {\n    return permissionGrantedResponse();\n  },\n  async requestMediaLibraryPermissionsAsync(_writeOnly) {\n    return permissionGrantedResponse();\n  }\n};\nfunction permissionGrantedResponse() {\n  return {\n    status: PermissionStatus.GRANTED,\n    expires: 'never',\n    granted: true,\n    canAskAgain: true\n  };\n}\nfunction openFileBrowserAsync({\n  mediaTypes,\n  capture = false,\n  allowsMultipleSelection = false,\n  base64\n}) {\n  const parsedMediaTypes = parseMediaTypes(mediaTypes);\n  const mediaTypeFormat = createMediaTypeFormat(parsedMediaTypes);\n  const input = document.createElement('input');\n  input.style.display = 'none';\n  input.setAttribute('type', 'file');\n  input.setAttribute('accept', mediaTypeFormat);\n  input.setAttribute('id', String(Math.random()));\n  input.setAttribute('data-testid', 'file-input');\n  if (allowsMultipleSelection) {\n    input.setAttribute('multiple', 'multiple');\n  }\n  if (capture) {\n    switch (capture) {\n      case true:\n        input.setAttribute('capture', 'camera');\n        break;\n      case CameraType.front:\n        input.setAttribute('capture', 'user');\n        break;\n      case CameraType.back:\n        input.setAttribute('capture', 'environment');\n    }\n  }\n  document.body.appendChild(input);\n  return new Promise(resolve => {\n    input.addEventListener('change', async () => {\n      if (input.files?.length) {\n        const files = allowsMultipleSelection ? input.files : [input.files[0]];\n        const assets = await Promise.all(Array.from(files).map(file => readFile(file, {\n          base64\n        })));\n        resolve({\n          canceled: false,\n          assets\n        });\n      } else {\n        resolve({\n          canceled: true,\n          assets: null\n        });\n      }\n      document.body.removeChild(input);\n    });\n    input.addEventListener('cancel', () => {\n      input.dispatchEvent(new Event('change'));\n    });\n    const event = new MouseEvent('click');\n    input.dispatchEvent(event);\n  });\n}\nasync function getImageMetadata(blobUrl) {\n  return new Promise(resolve => {\n    const image = new Image();\n    image.onload = () => {\n      resolve({\n        width: image.naturalWidth ?? image.width,\n        height: image.naturalHeight ?? image.height\n      });\n    };\n    image.onerror = () => resolve({\n      width: 0,\n      height: 0\n    });\n    image.src = blobUrl;\n  });\n}\nasync function getVideoMetadata(blobUrl) {\n  return new Promise(resolve => {\n    const video = document.createElement('video');\n    video.preload = 'metadata';\n    video.onloadedmetadata = () => {\n      resolve({\n        width: video.videoWidth,\n        height: video.videoHeight,\n        duration: video.duration\n      });\n    };\n    video.onerror = () => resolve({\n      width: 0,\n      height: 0,\n      duration: 0\n    });\n    video.src = blobUrl;\n  });\n}\nasync function readFileAsBase64(file) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onerror = () => {\n      reject(new Error('Failed to read the selected media because the operation failed.'));\n    };\n    reader.onload = event => {\n      const result = event.target?.result;\n      if (typeof result !== 'string') {\n        reject(new Error('Failed to read file as base64'));\n        return;\n      }\n      resolve(result.split(',')[1]);\n    };\n    reader.readAsDataURL(file);\n  });\n}\nasync function readFile(targetFile, options) {\n  const mimeType = targetFile.type;\n  const baseUri = URL.createObjectURL(targetFile);\n  try {\n    let metadata;\n    let base64;\n    if (mimeType.startsWith('image/')) {\n      metadata = await getImageMetadata(baseUri);\n    } else if (mimeType.startsWith('video/')) {\n      metadata = await getVideoMetadata(baseUri);\n    } else {\n      throw new Error(`Unsupported file type: ${mimeType}. Only images and videos are supported.`);\n    }\n    if (options.base64) {\n      base64 = await readFileAsBase64(targetFile);\n    }\n    return Object.assign({\n      uri: baseUri,\n      width: metadata.width,\n      height: metadata.height,\n      type: mimeType.startsWith('image/') ? 'image' : 'video',\n      mimeType,\n      fileName: targetFile.name,\n      fileSize: targetFile.size,\n      file: targetFile\n    }, metadata.duration !== undefined && {\n      duration: metadata.duration\n    }, base64 && {\n      base64\n    });\n  } catch (error) {\n    throw error;\n  }\n}\nfunction createMediaTypeFormat(mediaTypes) {\n  const filteredMediaTypes = mediaTypes.filter(mediaType => mediaType !== 'livePhotos');\n  if (filteredMediaTypes.length === 0) {\n    return 'image/*';\n  }\n  let result = '';\n  for (const mediaType of filteredMediaTypes) {\n    if (!result.includes(MediaTypeInput[mediaType])) {\n      result = result.concat(',', MediaTypeInput[mediaType]);\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["PermissionStatus","Platform","CameraType","parseMediaTypes","MediaTypeInput","images","videos","livePhotos","launchImageLibraryAsync","mediaTypes","allowsMultipleSelection","base64","isDOMAvailable","canceled","assets","openFileBrowserAsync","launchCameraAsync","cameraType","capture","getCameraPermissionsAsync","permissionGrantedResponse","requestCameraPermissionsAsync","getMediaLibraryPermissionsAsync","_writeOnly","requestMediaLibraryPermissionsAsync","status","GRANTED","expires","granted","canAskAgain","parsedMediaTypes","mediaTypeFormat","createMediaTypeFormat","input","document","createElement","style","display","setAttribute","String","Math","random","front","back","body","appendChild","Promise","resolve","addEventListener","files","length","all","Array","from","map","file","readFile","removeChild","dispatchEvent","Event","event","MouseEvent","getImageMetadata","blobUrl","image","Image","onload","width","naturalWidth","height","naturalHeight","onerror","src","getVideoMetadata","video","preload","onloadedmetadata","videoWidth","videoHeight","duration","readFileAsBase64","reject","reader","FileReader","Error","result","target","split","readAsDataURL","targetFile","options","mimeType","type","baseUri","URL","createObjectURL","metadata","startsWith","Object","assign","uri","fileName","name","fileSize","size","undefined","error","filteredMediaTypes","filter","mediaType","includes","concat"],"sources":["C:\\Users\\prana\\OneDrive\\Desktop\\civic-reporter-sih\\frontend\\node_modules\\expo-image-picker\\src\\ExponentImagePicker.web.ts"],"sourcesContent":["import { PermissionResponse, PermissionStatus, Platform } from 'expo-modules-core';\n\nimport {\n  CameraType,\n  ImagePickerAsset,\n  ImagePickerOptions,\n  ImagePickerResult,\n  MediaType,\n  OpenFileBrowserOptions,\n} from './ImagePicker.types';\nimport { parseMediaTypes } from './utils';\n\nconst MediaTypeInput: Record<MediaType, string> = {\n  images: 'image/*',\n  videos: 'video/mp4,video/quicktime,video/x-m4v,video/*',\n  livePhotos: '',\n};\n\nexport default {\n  async launchImageLibraryAsync({\n    mediaTypes = ['images'] as MediaType[],\n    allowsMultipleSelection = false,\n    base64 = false,\n  }: ImagePickerOptions): Promise<ImagePickerResult> {\n    // SSR guard\n    if (!Platform.isDOMAvailable) {\n      return { canceled: true, assets: null };\n    }\n    return await openFileBrowserAsync({\n      mediaTypes,\n      allowsMultipleSelection,\n      base64,\n    });\n  },\n\n  async launchCameraAsync({\n    mediaTypes = ['images'] as MediaType[],\n    allowsMultipleSelection = false,\n    base64 = false,\n    cameraType,\n  }: ImagePickerOptions): Promise<ImagePickerResult> {\n    // SSR guard\n    if (!Platform.isDOMAvailable) {\n      return { canceled: true, assets: null };\n    }\n    return await openFileBrowserAsync({\n      mediaTypes,\n      allowsMultipleSelection,\n      capture: cameraType ?? true,\n      base64,\n    });\n  },\n\n  /*\n   * Delegate to expo-permissions to request camera permissions\n   */\n  async getCameraPermissionsAsync() {\n    return permissionGrantedResponse();\n  },\n  async requestCameraPermissionsAsync() {\n    return permissionGrantedResponse();\n  },\n\n  /*\n   * Camera roll permissions don't need to be requested on web, so we always\n   * respond with granted.\n   */\n  async getMediaLibraryPermissionsAsync(_writeOnly: boolean) {\n    return permissionGrantedResponse();\n  },\n  async requestMediaLibraryPermissionsAsync(_writeOnly: boolean): Promise<PermissionResponse> {\n    return permissionGrantedResponse();\n  },\n};\n\nfunction permissionGrantedResponse(): PermissionResponse {\n  return {\n    status: PermissionStatus.GRANTED,\n    expires: 'never',\n    granted: true,\n    canAskAgain: true,\n  };\n}\n\n/**\n * Opens a file browser dialog or camera on supported platforms and returns the selected files.\n * Handles both single and multiple file selection.\n */\nfunction openFileBrowserAsync({\n  mediaTypes,\n  capture = false,\n  allowsMultipleSelection = false,\n  base64,\n}: OpenFileBrowserOptions): Promise<ImagePickerResult> {\n  const parsedMediaTypes = parseMediaTypes(mediaTypes);\n  const mediaTypeFormat = createMediaTypeFormat(parsedMediaTypes);\n\n  const input = document.createElement('input');\n  input.style.display = 'none';\n  input.setAttribute('type', 'file');\n  input.setAttribute('accept', mediaTypeFormat);\n  input.setAttribute('id', String(Math.random()));\n  input.setAttribute('data-testid', 'file-input');\n  if (allowsMultipleSelection) {\n    input.setAttribute('multiple', 'multiple');\n  }\n  if (capture) {\n    switch (capture) {\n      case true:\n        input.setAttribute('capture', 'camera');\n        break;\n      case CameraType.front:\n        input.setAttribute('capture', 'user');\n        break;\n      case CameraType.back:\n        input.setAttribute('capture', 'environment');\n    }\n  }\n  document.body.appendChild(input);\n\n  return new Promise((resolve) => {\n    input.addEventListener('change', async () => {\n      if (input.files?.length) {\n        const files = allowsMultipleSelection ? input.files : [input.files[0]];\n        const assets: ImagePickerAsset[] = await Promise.all(\n          Array.from(files).map((file) => readFile(file, { base64 }))\n        );\n\n        resolve({ canceled: false, assets });\n      } else {\n        resolve({ canceled: true, assets: null });\n      }\n      document.body.removeChild(input);\n    });\n    input.addEventListener('cancel', () => {\n      input.dispatchEvent(new Event('change'));\n    });\n\n    const event = new MouseEvent('click');\n    input.dispatchEvent(event);\n  });\n}\n\n/**\n * Gets metadata for an image file using a blob URL\n * TODO (Hirbod): add exif support for feature parity with native\n */\nasync function getImageMetadata(blobUrl: string): Promise<{ width: number; height: number }> {\n  return new Promise((resolve) => {\n    const image = new Image();\n    image.onload = () => {\n      resolve({\n        width: image.naturalWidth ?? image.width,\n        height: image.naturalHeight ?? image.height,\n      });\n    };\n    image.onerror = () => resolve({ width: 0, height: 0 });\n    image.src = blobUrl;\n  });\n}\n\n/**\n * Gets metadata for a video file using a blob URL\n */\nasync function getVideoMetadata(\n  blobUrl: string\n): Promise<{ width: number; height: number; duration: number }> {\n  return new Promise((resolve) => {\n    const video = document.createElement('video');\n    video.preload = 'metadata';\n    video.onloadedmetadata = () => {\n      resolve({\n        width: video.videoWidth,\n        height: video.videoHeight,\n        duration: video.duration,\n      });\n    };\n    video.onerror = () => resolve({ width: 0, height: 0, duration: 0 });\n    video.src = blobUrl;\n  });\n}\n\n/**\n * Reads a file as base64\n */\nasync function readFileAsBase64(file: File): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onerror = () => {\n      reject(new Error('Failed to read the selected media because the operation failed.'));\n    };\n    reader.onload = (event: ProgressEvent<FileReader>) => {\n      const result = event.target?.result;\n      if (typeof result !== 'string') {\n        reject(new Error('Failed to read file as base64'));\n        return;\n      }\n      // Remove the data URL prefix to get just the base64 data\n      resolve(result.split(',')[1]);\n    };\n    reader.readAsDataURL(file);\n  });\n}\n\n/**\n * Reads a file and returns its data as an ImagePickerAsset.\n * Handles both base64 and blob URL modes, and extracts metadata for images and videos.\n */\nasync function readFile(targetFile: File, options: { base64: boolean }): Promise<ImagePickerAsset> {\n  const mimeType = targetFile.type;\n  const baseUri = URL.createObjectURL(targetFile);\n\n  try {\n    let metadata: { width: number; height: number; duration?: number };\n    let base64: string | undefined;\n\n    if (mimeType.startsWith('image/')) {\n      metadata = await getImageMetadata(baseUri);\n    } else if (mimeType.startsWith('video/')) {\n      metadata = await getVideoMetadata(baseUri);\n    } else {\n      throw new Error(`Unsupported file type: ${mimeType}. Only images and videos are supported.`);\n    }\n\n    if (options.base64) {\n      base64 = await readFileAsBase64(targetFile);\n    }\n\n    return {\n      uri: baseUri,\n      width: metadata.width,\n      height: metadata.height,\n      type: mimeType.startsWith('image/') ? 'image' : 'video',\n      mimeType,\n      fileName: targetFile.name,\n      fileSize: targetFile.size,\n      file: targetFile,\n      ...(metadata.duration !== undefined && { duration: metadata.duration }),\n      ...(base64 && { base64 }),\n    };\n  } catch (error) {\n    throw error;\n  }\n}\n\n/**\n * Creates the accept attribute value for the file input based on the requested media types.\n * Filters out livePhotos as they're not supported on web.\n */\nfunction createMediaTypeFormat(mediaTypes: MediaType[]): string {\n  const filteredMediaTypes = mediaTypes.filter((mediaType) => mediaType !== 'livePhotos');\n  if (filteredMediaTypes.length === 0) {\n    return 'image/*';\n  }\n  let result = '';\n  for (const mediaType of filteredMediaTypes) {\n    // Make sure the types don't repeat\n    if (!result.includes(MediaTypeInput[mediaType])) {\n      result = result.concat(',', MediaTypeInput[mediaType]);\n    }\n  }\n  return result;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}