{"ast":null,"code":"'use strict';\n\nimport { ReanimatedError } from \"../../../../common/index.js\";\nimport { cubicBezier, linear, steps } from \"../../../easing/index.js\";\nimport { camelizeKebabCase, isArrayOfLength, isPercentage, isPredefinedTimingFunction, isStepsModifier, parseSingleTransitionShorthand, splitByComma, splitByWhitespace } from \"../../../utils/index.js\";\nexport const createEmptyTransitionConfig = () => ({\n  transitionProperty: [],\n  transitionDuration: [],\n  transitionTimingFunction: [],\n  transitionDelay: [],\n  transitionBehavior: []\n});\nexport function parseTransitionShorthand(value) {\n  return splitByComma(value).reduce((acc, part) => {\n    const result = parseSingleTransitionShorthand(part);\n    acc.transitionProperty.push(camelizeKebabCase(result.transitionProperty ?? 'all'));\n    acc.transitionDuration.push(result.transitionDuration);\n    acc.transitionTimingFunction.push(result.transitionTimingFunction ? parseTimingFunction(result.transitionTimingFunction) : undefined);\n    acc.transitionDelay.push(result.transitionDelay);\n    acc.transitionBehavior.push(result.transitionBehavior);\n    return acc;\n  }, createEmptyTransitionConfig());\n}\nfunction asControlPoint(value) {\n  const [first, ...rest] = value;\n  if (!first || isNaN(Number(first)) || !rest.every(isPercentage)) {\n    return null;\n  }\n  return [Number(first), ...rest];\n}\nfunction parseTimingFunction(value) {\n  if (isPredefinedTimingFunction(value)) {\n    return value;\n  }\n  const regex = /^(.+)\\((.+)\\)$/;\n  if (!regex.test(value)) {\n    throw new ReanimatedError(`Unsupported timing function: ${value}`);\n  }\n  const [, name, args] = value.match(regex);\n  const parsedArgs = splitByComma(args);\n  switch (name) {\n    case 'cubic-bezier':\n      {\n        const numberArgs = parsedArgs.map(Number);\n        if (isArrayOfLength(numberArgs, 4) && numberArgs.every(n => !isNaN(n))) {\n          return cubicBezier(...numberArgs);\n        }\n        break;\n      }\n    case 'linear':\n      {\n        const controlPoints = parsedArgs.map(arg => {\n          const parts = splitByWhitespace(arg);\n          const controlPoint = asControlPoint(parts);\n          if (!controlPoint) {\n            throw new ReanimatedError(`Invalid control point: ${arg} in ${value} timing function`);\n          }\n          return controlPoint;\n        });\n        return linear(...controlPoints);\n      }\n    case 'steps':\n      {\n        const stepsNumber = Number(parsedArgs[0]);\n        const stepsModifier = parsedArgs[1];\n        if (!isNaN(stepsNumber) && stepsNumber > 0 && (stepsModifier === undefined || isStepsModifier(stepsModifier))) {\n          return steps(stepsNumber, stepsModifier);\n        }\n        break;\n      }\n  }\n  throw new ReanimatedError(`Invalid timing function: ${value}`);\n}","map":{"version":3,"names":["ReanimatedError","cubicBezier","linear","steps","camelizeKebabCase","isArrayOfLength","isPercentage","isPredefinedTimingFunction","isStepsModifier","parseSingleTransitionShorthand","splitByComma","splitByWhitespace","createEmptyTransitionConfig","transitionProperty","transitionDuration","transitionTimingFunction","transitionDelay","transitionBehavior","parseTransitionShorthand","value","reduce","acc","part","result","push","parseTimingFunction","undefined","asControlPoint","first","rest","isNaN","Number","every","regex","test","name","args","match","parsedArgs","numberArgs","map","n","controlPoints","arg","parts","controlPoint","stepsNumber","stepsModifier"],"sources":["C:\\Users\\prana\\OneDrive\\Desktop\\civic-reporter-sih\\frontend\\node_modules\\react-native-reanimated\\src\\css\\native\\normalization\\transition\\shorthand.ts"],"sourcesContent":["'use strict';\nimport { ReanimatedError } from '../../../../common';\nimport type { ControlPoint, CSSTimingFunction } from '../../../easing';\nimport { cubicBezier, linear, steps } from '../../../easing';\nimport type {\n  ConvertValuesToArraysWithUndefined,\n  CSSTransitionProperties,\n} from '../../../types';\nimport {\n  camelizeKebabCase,\n  isArrayOfLength,\n  isPercentage,\n  isPredefinedTimingFunction,\n  isStepsModifier,\n  parseSingleTransitionShorthand,\n  splitByComma,\n  splitByWhitespace,\n} from '../../../utils';\n\nexport type ExpandedCSSTransitionConfigProperties = Required<\n  ConvertValuesToArraysWithUndefined<\n    Omit<CSSTransitionProperties, 'transition' | 'transitionProperty'>\n  >\n> & {\n  transitionProperty: string[];\n};\n\nexport const createEmptyTransitionConfig =\n  (): ExpandedCSSTransitionConfigProperties => ({\n    transitionProperty: [],\n    transitionDuration: [],\n    transitionTimingFunction: [],\n    transitionDelay: [],\n    transitionBehavior: [],\n  });\n\nexport function parseTransitionShorthand(value: string) {\n  return splitByComma(value).reduce<ExpandedCSSTransitionConfigProperties>(\n    (acc, part) => {\n      const result = parseSingleTransitionShorthand(part);\n      acc.transitionProperty.push(\n        camelizeKebabCase(result.transitionProperty ?? 'all')\n      );\n      acc.transitionDuration.push(result.transitionDuration);\n      acc.transitionTimingFunction.push(\n        result.transitionTimingFunction\n          ? parseTimingFunction(result.transitionTimingFunction)\n          : undefined\n      );\n      acc.transitionDelay.push(result.transitionDelay);\n      acc.transitionBehavior.push(result.transitionBehavior);\n      return acc;\n    },\n    createEmptyTransitionConfig()\n  );\n}\n\nfunction asControlPoint(value: string[]): ControlPoint | null {\n  const [first, ...rest] = value;\n  if (!first || isNaN(Number(first)) || !rest.every(isPercentage)) {\n    return null;\n  }\n  return [Number(first), ...rest];\n}\n\nfunction parseTimingFunction(value: string): CSSTimingFunction {\n  if (isPredefinedTimingFunction(value)) {\n    return value;\n  }\n\n  // TODO: implement more strict check\n  const regex = /^(.+)\\((.+)\\)$/;\n  if (!regex.test(value)) {\n    throw new ReanimatedError(`Unsupported timing function: ${value}`);\n  }\n\n  const [, name, args] = value.match(regex)!;\n  const parsedArgs = splitByComma(args);\n\n  switch (name) {\n    case 'cubic-bezier': {\n      const numberArgs = parsedArgs.map(Number);\n      if (\n        isArrayOfLength(numberArgs, 4) &&\n        numberArgs.every((n) => !isNaN(n))\n      ) {\n        return cubicBezier(...numberArgs);\n      }\n      break;\n    }\n    case 'linear': {\n      const controlPoints = parsedArgs.map((arg) => {\n        const parts = splitByWhitespace(arg);\n        const controlPoint = asControlPoint(parts);\n        if (!controlPoint) {\n          throw new ReanimatedError(\n            `Invalid control point: ${arg} in ${value} timing function`\n          );\n        }\n        return controlPoint;\n      });\n      return linear(...controlPoints);\n    }\n    case 'steps': {\n      const stepsNumber = Number(parsedArgs[0]);\n      const stepsModifier = parsedArgs[1];\n      if (\n        !isNaN(stepsNumber) &&\n        stepsNumber > 0 &&\n        (stepsModifier === undefined || isStepsModifier(stepsModifier))\n      ) {\n        return steps(stepsNumber, stepsModifier);\n      }\n      break;\n    }\n  }\n\n  throw new ReanimatedError(`Invalid timing function: ${value}`);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}