{"ast":null,"code":"import AsyncStorage from '@react-native-async-storage/async-storage';\nimport NetInfo from '@react-native-netinfo/netinfo';\nimport { apiService } from './apiService';\nclass OfflineService {\n  isOnline = true;\n  syncInProgress = false;\n  pendingActions = [];\n  offlineData = {\n    assignments: [],\n    workLogs: [],\n    photos: [],\n    lastSync: new Date().toISOString()\n  };\n  constructor() {\n    this.initializeNetworkListener();\n    this.loadOfflineData();\n  }\n  async initializeNetworkListener() {\n    NetInfo.addEventListener(state => {\n      const wasOffline = !this.isOnline;\n      this.isOnline = state.isConnected || false;\n      console.log('üåê Network status:', this.isOnline ? 'Online' : 'Offline');\n      if (wasOffline && this.isOnline) {\n        this.syncPendingActions();\n      }\n    });\n    const state = await NetInfo.fetch();\n    this.isOnline = state.isConnected || false;\n  }\n  async loadOfflineData() {\n    try {\n      const storedData = await AsyncStorage.getItem('offlineData');\n      if (storedData) {\n        this.offlineData = JSON.parse(storedData);\n      }\n      const storedActions = await AsyncStorage.getItem('pendingActions');\n      if (storedActions) {\n        this.pendingActions = JSON.parse(storedActions);\n      }\n    } catch (error) {\n      console.error('Error loading offline data:', error);\n    }\n  }\n  async saveOfflineData() {\n    try {\n      await AsyncStorage.setItem('offlineData', JSON.stringify(this.offlineData));\n      await AsyncStorage.setItem('pendingActions', JSON.stringify(this.pendingActions));\n    } catch (error) {\n      console.error('Error saving offline data:', error);\n    }\n  }\n  isDeviceOnline() {\n    return this.isOnline;\n  }\n  async addPendingAction(type, data) {\n    const action = {\n      id: Date.now().toString() + Math.random().toString(36).substr(2, 9),\n      type,\n      data,\n      timestamp: new Date().toISOString(),\n      retryCount: 0\n    };\n    this.pendingActions.push(action);\n    await this.saveOfflineData();\n    console.log(`üì± Added offline action: ${type}`, action.id);\n    if (this.isOnline) {\n      this.syncPendingActions();\n    }\n    return action.id;\n  }\n  async syncPendingActions() {\n    if (!this.isOnline || this.syncInProgress || this.pendingActions.length === 0) {\n      return;\n    }\n    this.syncInProgress = true;\n    console.log('üîÑ Syncing pending actions...', this.pendingActions.length);\n    const actionsToSync = [...this.pendingActions];\n    const successfulActions = [];\n    for (const action of actionsToSync) {\n      try {\n        const success = await this.executeAction(action);\n        if (success) {\n          successfulActions.push(action.id);\n          console.log(`‚úÖ Synced action: ${action.type} - ${action.id}`);\n        } else {\n          action.retryCount++;\n          if (action.retryCount >= 3) {\n            console.error(`‚ùå Failed to sync action after 3 retries: ${action.type} - ${action.id}`);\n            successfulActions.push(action.id);\n          }\n        }\n      } catch (error) {\n        console.error(`Error syncing action ${action.id}:`, error);\n        action.retryCount++;\n        if (action.retryCount >= 3) {\n          successfulActions.push(action.id);\n        }\n      }\n    }\n    this.pendingActions = this.pendingActions.filter(action => !successfulActions.includes(action.id));\n    await this.saveOfflineData();\n    this.syncInProgress = false;\n    console.log(`üîÑ Sync complete. Remaining actions: ${this.pendingActions.length}`);\n  }\n  async executeAction(action) {\n    try {\n      switch (action.type) {\n        case 'WORK_LOG':\n          return await this.syncWorkLog(action.data);\n        case 'ASSIGNMENT_UPDATE':\n          return await this.syncAssignmentUpdate(action.data);\n        case 'PHOTO_UPLOAD':\n          return await this.syncPhotoUpload(action.data);\n        case 'CHECK_IN':\n          return await this.syncCheckIn(action.data);\n        case 'CHECK_OUT':\n          return await this.syncCheckOut(action.data);\n        default:\n          console.warn('Unknown action type:', action.type);\n          return false;\n      }\n    } catch (error) {\n      console.error(`Error executing action ${action.type}:`, error);\n      return false;\n    }\n  }\n  async syncWorkLog(data) {\n    try {\n      const response = await apiService.post('/workers/work-logs', data);\n      return response.success;\n    } catch (error) {\n      return false;\n    }\n  }\n  async syncAssignmentUpdate(data) {\n    try {\n      const response = await apiService.put(`/assignments/${data.assignmentId}`, data.updates);\n      return response.success;\n    } catch (error) {\n      return false;\n    }\n  }\n  async syncPhotoUpload(data) {\n    try {\n      const formData = new FormData();\n      formData.append('photo', {\n        uri: data.uri,\n        type: data.type,\n        name: data.name\n      });\n      formData.append('workerId', data.workerId);\n      formData.append('assignmentId', data.assignmentId);\n      formData.append('location', JSON.stringify(data.location));\n      const response = await apiService.post('/uploads/work-progress', formData, {\n        headers: {\n          'Content-Type': 'multipart/form-data'\n        }\n      });\n      return response.success;\n    } catch (error) {\n      return false;\n    }\n  }\n  async syncCheckIn(data) {\n    try {\n      const response = await apiService.post('/workers/check-in', data);\n      return response.success;\n    } catch (error) {\n      return false;\n    }\n  }\n  async syncCheckOut(data) {\n    try {\n      const response = await apiService.post('/workers/check-out', data);\n      return response.success;\n    } catch (error) {\n      return false;\n    }\n  }\n  async storeAssignmentsOffline(assignments) {\n    this.offlineData.assignments = assignments;\n    this.offlineData.lastSync = new Date().toISOString();\n    await this.saveOfflineData();\n  }\n  async getOfflineAssignments() {\n    return this.offlineData.assignments;\n  }\n  async storeWorkLogOffline(workLog) {\n    this.offlineData.workLogs.push(Object.assign({}, workLog, {\n      id: Date.now().toString(),\n      timestamp: new Date().toISOString(),\n      synced: false\n    }));\n    await this.saveOfflineData();\n  }\n  async getOfflineWorkLogs() {\n    return this.offlineData.workLogs;\n  }\n  async storePhotoOffline(photoData) {\n    const photoId = Date.now().toString();\n    const photo = Object.assign({\n      id: photoId\n    }, photoData, {\n      timestamp: new Date().toISOString(),\n      synced: false\n    });\n    this.offlineData.photos.push(photo);\n    await this.saveOfflineData();\n    await this.addPendingAction('PHOTO_UPLOAD', photoData);\n    return photoId;\n  }\n  async getOfflinePhotos() {\n    return this.offlineData.photos;\n  }\n  getSyncStatus() {\n    return {\n      isOnline: this.isOnline,\n      pendingActions: this.pendingActions.length,\n      lastSync: this.offlineData.lastSync,\n      syncInProgress: this.syncInProgress\n    };\n  }\n  async forcSync() {\n    if (this.isOnline) {\n      await this.syncPendingActions();\n    } else {\n      throw new Error('Device is offline. Cannot sync.');\n    }\n  }\n  async clearOfflineData() {\n    this.offlineData = {\n      assignments: [],\n      workLogs: [],\n      photos: [],\n      lastSync: new Date().toISOString()\n    };\n    this.pendingActions = [];\n    await AsyncStorage.removeItem('offlineData');\n    await AsyncStorage.removeItem('pendingActions');\n  }\n  async getStorageSize() {\n    try {\n      const offlineDataStr = await AsyncStorage.getItem('offlineData');\n      const pendingActionsStr = await AsyncStorage.getItem('pendingActions');\n      const size = (offlineDataStr?.length || 0) + (pendingActionsStr?.length || 0);\n      const items = this.offlineData.assignments.length + this.offlineData.workLogs.length + this.offlineData.photos.length + this.pendingActions.length;\n      return {\n        size,\n        items\n      };\n    } catch (error) {\n      return {\n        size: 0,\n        items: 0\n      };\n    }\n  }\n}\nexport const offlineService = new OfflineService();\nexport default offlineService;","map":{"version":3,"names":["AsyncStorage","NetInfo","apiService","OfflineService","isOnline","syncInProgress","pendingActions","offlineData","assignments","workLogs","photos","lastSync","Date","toISOString","constructor","initializeNetworkListener","loadOfflineData","addEventListener","state","wasOffline","isConnected","console","log","syncPendingActions","fetch","storedData","getItem","JSON","parse","storedActions","error","saveOfflineData","setItem","stringify","isDeviceOnline","addPendingAction","type","data","action","id","now","toString","Math","random","substr","timestamp","retryCount","push","length","actionsToSync","successfulActions","success","executeAction","filter","includes","syncWorkLog","syncAssignmentUpdate","syncPhotoUpload","syncCheckIn","syncCheckOut","warn","response","post","put","assignmentId","updates","formData","FormData","append","uri","name","workerId","location","headers","storeAssignmentsOffline","getOfflineAssignments","storeWorkLogOffline","workLog","Object","assign","synced","getOfflineWorkLogs","storePhotoOffline","photoData","photoId","photo","getOfflinePhotos","getSyncStatus","forcSync","Error","clearOfflineData","removeItem","getStorageSize","offlineDataStr","pendingActionsStr","size","items","offlineService"],"sources":["C:/Users/prana/OneDrive/Desktop/civic-reporter-sih/frontend/src/services/offlineService.ts"],"sourcesContent":["import AsyncStorage from '@react-native-async-storage/async-storage';\nimport NetInfo from '@react-native-netinfo/netinfo';\nimport { apiService } from './apiService';\n\ninterface OfflineAction {\n  id: string;\n  type: 'WORK_LOG' | 'ASSIGNMENT_UPDATE' | 'PHOTO_UPLOAD' | 'CHECK_IN' | 'CHECK_OUT';\n  data: any;\n  timestamp: string;\n  retryCount: number;\n}\n\ninterface OfflineData {\n  assignments: any[];\n  workLogs: any[];\n  photos: any[];\n  lastSync: string;\n}\n\nclass OfflineService {\n  private isOnline: boolean = true;\n  private syncInProgress: boolean = false;\n  private pendingActions: OfflineAction[] = [];\n  private offlineData: OfflineData = {\n    assignments: [],\n    workLogs: [],\n    photos: [],\n    lastSync: new Date().toISOString()\n  };\n\n  constructor() {\n    this.initializeNetworkListener();\n    this.loadOfflineData();\n  }\n\n  private async initializeNetworkListener() {\n    // Listen for network state changes\n    NetInfo.addEventListener(state => {\n      const wasOffline = !this.isOnline;\n      this.isOnline = state.isConnected || false;\n      \n      console.log('üåê Network status:', this.isOnline ? 'Online' : 'Offline');\n      \n      // If we just came back online, sync pending actions\n      if (wasOffline && this.isOnline) {\n        this.syncPendingActions();\n      }\n    });\n\n    // Get initial network state\n    const state = await NetInfo.fetch();\n    this.isOnline = state.isConnected || false;\n  }\n\n  private async loadOfflineData() {\n    try {\n      const storedData = await AsyncStorage.getItem('offlineData');\n      if (storedData) {\n        this.offlineData = JSON.parse(storedData);\n      }\n\n      const storedActions = await AsyncStorage.getItem('pendingActions');\n      if (storedActions) {\n        this.pendingActions = JSON.parse(storedActions);\n      }\n    } catch (error) {\n      console.error('Error loading offline data:', error);\n    }\n  }\n\n  private async saveOfflineData() {\n    try {\n      await AsyncStorage.setItem('offlineData', JSON.stringify(this.offlineData));\n      await AsyncStorage.setItem('pendingActions', JSON.stringify(this.pendingActions));\n    } catch (error) {\n      console.error('Error saving offline data:', error);\n    }\n  }\n\n  // Check if device is online\n  isDeviceOnline(): boolean {\n    return this.isOnline;\n  }\n\n  // Add action to pending queue for offline execution\n  async addPendingAction(type: OfflineAction['type'], data: any): Promise<string> {\n    const action: OfflineAction = {\n      id: Date.now().toString() + Math.random().toString(36).substr(2, 9),\n      type,\n      data,\n      timestamp: new Date().toISOString(),\n      retryCount: 0\n    };\n\n    this.pendingActions.push(action);\n    await this.saveOfflineData();\n\n    console.log(`üì± Added offline action: ${type}`, action.id);\n\n    // If online, try to sync immediately\n    if (this.isOnline) {\n      this.syncPendingActions();\n    }\n\n    return action.id;\n  }\n\n  // Sync all pending actions when back online\n  async syncPendingActions(): Promise<void> {\n    if (!this.isOnline || this.syncInProgress || this.pendingActions.length === 0) {\n      return;\n    }\n\n    this.syncInProgress = true;\n    console.log('üîÑ Syncing pending actions...', this.pendingActions.length);\n\n    const actionsToSync = [...this.pendingActions];\n    const successfulActions: string[] = [];\n\n    for (const action of actionsToSync) {\n      try {\n        const success = await this.executeAction(action);\n        if (success) {\n          successfulActions.push(action.id);\n          console.log(`‚úÖ Synced action: ${action.type} - ${action.id}`);\n        } else {\n          // Increment retry count\n          action.retryCount++;\n          if (action.retryCount >= 3) {\n            console.error(`‚ùå Failed to sync action after 3 retries: ${action.type} - ${action.id}`);\n            successfulActions.push(action.id); // Remove from queue to prevent infinite retries\n          }\n        }\n      } catch (error) {\n        console.error(`Error syncing action ${action.id}:`, error);\n        action.retryCount++;\n        if (action.retryCount >= 3) {\n          successfulActions.push(action.id);\n        }\n      }\n    }\n\n    // Remove successful actions from pending queue\n    this.pendingActions = this.pendingActions.filter(\n      action => !successfulActions.includes(action.id)\n    );\n\n    await this.saveOfflineData();\n    this.syncInProgress = false;\n\n    console.log(`üîÑ Sync complete. Remaining actions: ${this.pendingActions.length}`);\n  }\n\n  private async executeAction(action: OfflineAction): Promise<boolean> {\n    try {\n      switch (action.type) {\n        case 'WORK_LOG':\n          return await this.syncWorkLog(action.data);\n        \n        case 'ASSIGNMENT_UPDATE':\n          return await this.syncAssignmentUpdate(action.data);\n        \n        case 'PHOTO_UPLOAD':\n          return await this.syncPhotoUpload(action.data);\n        \n        case 'CHECK_IN':\n          return await this.syncCheckIn(action.data);\n        \n        case 'CHECK_OUT':\n          return await this.syncCheckOut(action.data);\n        \n        default:\n          console.warn('Unknown action type:', action.type);\n          return false;\n      }\n    } catch (error) {\n      console.error(`Error executing action ${action.type}:`, error);\n      return false;\n    }\n  }\n\n  private async syncWorkLog(data: any): Promise<boolean> {\n    try {\n      const response = await apiService.post('/workers/work-logs', data);\n      return response.success;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  private async syncAssignmentUpdate(data: any): Promise<boolean> {\n    try {\n      const response = await apiService.put(`/assignments/${data.assignmentId}`, data.updates);\n      return response.success;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  private async syncPhotoUpload(data: any): Promise<boolean> {\n    try {\n      const formData = new FormData();\n      formData.append('photo', {\n        uri: data.uri,\n        type: data.type,\n        name: data.name,\n      } as any);\n      formData.append('workerId', data.workerId);\n      formData.append('assignmentId', data.assignmentId);\n      formData.append('location', JSON.stringify(data.location));\n\n      const response = await apiService.post('/uploads/work-progress', formData, {\n        headers: { 'Content-Type': 'multipart/form-data' }\n      });\n      return response.success;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  private async syncCheckIn(data: any): Promise<boolean> {\n    try {\n      const response = await apiService.post('/workers/check-in', data);\n      return response.success;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  private async syncCheckOut(data: any): Promise<boolean> {\n    try {\n      const response = await apiService.post('/workers/check-out', data);\n      return response.success;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  // Store data locally for offline access\n  async storeAssignmentsOffline(assignments: any[]): Promise<void> {\n    this.offlineData.assignments = assignments;\n    this.offlineData.lastSync = new Date().toISOString();\n    await this.saveOfflineData();\n  }\n\n  async getOfflineAssignments(): Promise<any[]> {\n    return this.offlineData.assignments;\n  }\n\n  // Store work logs locally\n  async storeWorkLogOffline(workLog: any): Promise<void> {\n    this.offlineData.workLogs.push({\n      ...workLog,\n      id: Date.now().toString(),\n      timestamp: new Date().toISOString(),\n      synced: false\n    });\n    await this.saveOfflineData();\n  }\n\n  async getOfflineWorkLogs(): Promise<any[]> {\n    return this.offlineData.workLogs;\n  }\n\n  // Store photos locally for later upload\n  async storePhotoOffline(photoData: any): Promise<string> {\n    const photoId = Date.now().toString();\n    const photo = {\n      id: photoId,\n      ...photoData,\n      timestamp: new Date().toISOString(),\n      synced: false\n    };\n\n    this.offlineData.photos.push(photo);\n    await this.saveOfflineData();\n\n    // Add to pending actions for sync\n    await this.addPendingAction('PHOTO_UPLOAD', photoData);\n\n    return photoId;\n  }\n\n  async getOfflinePhotos(): Promise<any[]> {\n    return this.offlineData.photos;\n  }\n\n  // Get sync status\n  getSyncStatus(): {\n    isOnline: boolean;\n    pendingActions: number;\n    lastSync: string;\n    syncInProgress: boolean;\n  } {\n    return {\n      isOnline: this.isOnline,\n      pendingActions: this.pendingActions.length,\n      lastSync: this.offlineData.lastSync,\n      syncInProgress: this.syncInProgress\n    };\n  }\n\n  // Manual sync trigger\n  async forcSync(): Promise<void> {\n    if (this.isOnline) {\n      await this.syncPendingActions();\n    } else {\n      throw new Error('Device is offline. Cannot sync.');\n    }\n  }\n\n  // Clear offline data (for logout or reset)\n  async clearOfflineData(): Promise<void> {\n    this.offlineData = {\n      assignments: [],\n      workLogs: [],\n      photos: [],\n      lastSync: new Date().toISOString()\n    };\n    this.pendingActions = [];\n    \n    await AsyncStorage.removeItem('offlineData');\n    await AsyncStorage.removeItem('pendingActions');\n  }\n\n  // Get offline storage size\n  async getStorageSize(): Promise<{ size: number; items: number }> {\n    try {\n      const offlineDataStr = await AsyncStorage.getItem('offlineData');\n      const pendingActionsStr = await AsyncStorage.getItem('pendingActions');\n      \n      const size = (offlineDataStr?.length || 0) + (pendingActionsStr?.length || 0);\n      const items = this.offlineData.assignments.length + \n                   this.offlineData.workLogs.length + \n                   this.offlineData.photos.length + \n                   this.pendingActions.length;\n\n      return { size, items };\n    } catch (error) {\n      return { size: 0, items: 0 };\n    }\n  }\n}\n\nexport const offlineService = new OfflineService();\nexport default offlineService;\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}