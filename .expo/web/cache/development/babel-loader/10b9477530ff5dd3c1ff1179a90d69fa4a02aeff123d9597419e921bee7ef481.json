{"ast":null,"code":"\"use strict\";\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nconst _excluded = [\"enabled\"];\nimport { State } from '../../State';\nimport { DiagonalDirections, Directions } from '../../Directions';\nimport GestureHandler from './GestureHandler';\nimport Vector from '../tools/Vector';\nimport { coneToDeviation } from '../utils';\nconst DEFAULT_MAX_DURATION_MS = 800;\nconst DEFAULT_MIN_VELOCITY = 700;\nconst DEFAULT_ALIGNMENT_CONE = 30;\nconst DEFAULT_DIRECTION = Directions.RIGHT;\nconst DEFAULT_NUMBER_OF_TOUCHES_REQUIRED = 1;\nconst AXIAL_DEVIATION_COSINE = coneToDeviation(DEFAULT_ALIGNMENT_CONE);\nconst DIAGONAL_DEVIATION_COSINE = coneToDeviation(90 - DEFAULT_ALIGNMENT_CONE);\nexport default class FlingGestureHandler extends GestureHandler {\n  numberOfPointersRequired = DEFAULT_NUMBER_OF_TOUCHES_REQUIRED;\n  direction = DEFAULT_DIRECTION;\n  maxDurationMs = DEFAULT_MAX_DURATION_MS;\n  minVelocity = DEFAULT_MIN_VELOCITY;\n  maxNumberOfPointersSimultaneously = 0;\n  keyPointer = NaN;\n  updateGestureConfig(_ref) {\n    let {\n        enabled = true\n      } = _ref,\n      props = _objectWithoutPropertiesLoose(_ref, _excluded);\n    super.updateGestureConfig(Object.assign({\n      enabled: enabled\n    }, props));\n    if (this.config.direction) {\n      this.direction = this.config.direction;\n    }\n    if (this.config.numberOfPointers) {\n      this.numberOfPointersRequired = this.config.numberOfPointers;\n    }\n  }\n  startFling() {\n    this.begin();\n    this.maxNumberOfPointersSimultaneously = 1;\n    this.delayTimeout = setTimeout(() => this.fail(), this.maxDurationMs);\n  }\n  tryEndFling() {\n    const velocityVector = Vector.fromVelocity(this.tracker, this.keyPointer);\n    if (!velocityVector) {\n      return false;\n    }\n    const getAlignment = (direction, minimalAlignmentCosine) => {\n      return (direction & this.direction) === direction && velocityVector.isSimilar(Vector.fromDirection(direction), minimalAlignmentCosine);\n    };\n    const axialDirectionsList = Object.values(Directions);\n    const diagonalDirectionsList = Object.values(DiagonalDirections);\n    const axialAlignmentList = axialDirectionsList.map(direction => getAlignment(direction, AXIAL_DEVIATION_COSINE));\n    const diagonalAlignmentList = diagonalDirectionsList.map(direction => getAlignment(direction, DIAGONAL_DEVIATION_COSINE));\n    const isAligned = axialAlignmentList.some(Boolean) || diagonalAlignmentList.some(Boolean);\n    const isFast = velocityVector.magnitude > this.minVelocity;\n    if (this.maxNumberOfPointersSimultaneously === this.numberOfPointersRequired && isAligned && isFast) {\n      clearTimeout(this.delayTimeout);\n      this.activate();\n      return true;\n    }\n    return false;\n  }\n  endFling() {\n    if (!this.tryEndFling()) {\n      this.fail();\n    }\n  }\n  onPointerDown(event) {\n    if (!this.isButtonInConfig(event.button)) {\n      return;\n    }\n    this.tracker.addToTracker(event);\n    this.keyPointer = event.pointerId;\n    super.onPointerDown(event);\n    this.newPointerAction();\n    this.tryToSendTouchEvent(event);\n  }\n  onPointerAdd(event) {\n    this.tracker.addToTracker(event);\n    super.onPointerAdd(event);\n    this.newPointerAction();\n  }\n  newPointerAction() {\n    if (this.state === State.UNDETERMINED) {\n      this.startFling();\n    }\n    if (this.state !== State.BEGAN) {\n      return;\n    }\n    this.tryEndFling();\n    if (this.tracker.trackedPointersCount > this.maxNumberOfPointersSimultaneously) {\n      this.maxNumberOfPointersSimultaneously = this.tracker.trackedPointersCount;\n    }\n  }\n  pointerMoveAction(event) {\n    this.tracker.track(event);\n    if (this.state !== State.BEGAN) {\n      return;\n    }\n    this.tryEndFling();\n  }\n  onPointerMove(event) {\n    this.pointerMoveAction(event);\n    super.onPointerMove(event);\n  }\n  onPointerOutOfBounds(event) {\n    this.pointerMoveAction(event);\n    super.onPointerOutOfBounds(event);\n  }\n  onPointerUp(event) {\n    super.onPointerUp(event);\n    this.onUp(event);\n    this.keyPointer = NaN;\n  }\n  onPointerRemove(event) {\n    super.onPointerRemove(event);\n    this.onUp(event);\n  }\n  onUp(event) {\n    if (this.state === State.BEGAN) {\n      this.endFling();\n    }\n    this.tracker.removeFromTracker(event.pointerId);\n  }\n  activate(force) {\n    super.activate(force);\n    this.end();\n  }\n  resetConfig() {\n    super.resetConfig();\n    this.numberOfPointersRequired = DEFAULT_NUMBER_OF_TOUCHES_REQUIRED;\n    this.direction = DEFAULT_DIRECTION;\n  }\n}","map":{"version":3,"names":["State","DiagonalDirections","Directions","GestureHandler","Vector","coneToDeviation","DEFAULT_MAX_DURATION_MS","DEFAULT_MIN_VELOCITY","DEFAULT_ALIGNMENT_CONE","DEFAULT_DIRECTION","RIGHT","DEFAULT_NUMBER_OF_TOUCHES_REQUIRED","AXIAL_DEVIATION_COSINE","DIAGONAL_DEVIATION_COSINE","FlingGestureHandler","numberOfPointersRequired","direction","maxDurationMs","minVelocity","maxNumberOfPointersSimultaneously","keyPointer","NaN","updateGestureConfig","_ref","enabled","props","_objectWithoutPropertiesLoose","_excluded","Object","assign","config","numberOfPointers","startFling","begin","delayTimeout","setTimeout","fail","tryEndFling","velocityVector","fromVelocity","tracker","getAlignment","minimalAlignmentCosine","isSimilar","fromDirection","axialDirectionsList","values","diagonalDirectionsList","axialAlignmentList","map","diagonalAlignmentList","isAligned","some","Boolean","isFast","magnitude","clearTimeout","activate","endFling","onPointerDown","event","isButtonInConfig","button","addToTracker","pointerId","newPointerAction","tryToSendTouchEvent","onPointerAdd","state","UNDETERMINED","BEGAN","trackedPointersCount","pointerMoveAction","track","onPointerMove","onPointerOutOfBounds","onPointerUp","onUp","onPointerRemove","removeFromTracker","force","end","resetConfig"],"sources":["C:\\Users\\prana\\OneDrive\\Desktop\\civic-reporter-sih\\frontend\\node_modules\\react-native-gesture-handler\\src\\web\\handlers\\FlingGestureHandler.ts"],"sourcesContent":["import { State } from '../../State';\nimport { DiagonalDirections, Directions } from '../../Directions';\nimport { AdaptedEvent, Config } from '../interfaces';\n\nimport GestureHandler from './GestureHandler';\nimport Vector from '../tools/Vector';\nimport { coneToDeviation } from '../utils';\n\nconst DEFAULT_MAX_DURATION_MS = 800;\nconst DEFAULT_MIN_VELOCITY = 700;\nconst DEFAULT_ALIGNMENT_CONE = 30;\nconst DEFAULT_DIRECTION = Directions.RIGHT;\nconst DEFAULT_NUMBER_OF_TOUCHES_REQUIRED = 1;\n\nconst AXIAL_DEVIATION_COSINE = coneToDeviation(DEFAULT_ALIGNMENT_CONE);\nconst DIAGONAL_DEVIATION_COSINE = coneToDeviation(90 - DEFAULT_ALIGNMENT_CONE);\n\nexport default class FlingGestureHandler extends GestureHandler {\n  private numberOfPointersRequired = DEFAULT_NUMBER_OF_TOUCHES_REQUIRED;\n  private direction: Directions = DEFAULT_DIRECTION;\n\n  private maxDurationMs = DEFAULT_MAX_DURATION_MS;\n  private minVelocity = DEFAULT_MIN_VELOCITY;\n  private delayTimeout!: number;\n\n  private maxNumberOfPointersSimultaneously = 0;\n  private keyPointer = NaN;\n\n  public updateGestureConfig({ enabled = true, ...props }: Config): void {\n    super.updateGestureConfig({ enabled: enabled, ...props });\n\n    if (this.config.direction) {\n      this.direction = this.config.direction;\n    }\n\n    if (this.config.numberOfPointers) {\n      this.numberOfPointersRequired = this.config.numberOfPointers;\n    }\n  }\n\n  private startFling(): void {\n    this.begin();\n\n    this.maxNumberOfPointersSimultaneously = 1;\n\n    this.delayTimeout = setTimeout(() => this.fail(), this.maxDurationMs);\n  }\n\n  private tryEndFling(): boolean {\n    const velocityVector = Vector.fromVelocity(this.tracker, this.keyPointer);\n\n    if (!velocityVector) {\n      return false;\n    }\n\n    const getAlignment = (\n      direction: Directions | DiagonalDirections,\n      minimalAlignmentCosine: number\n    ) => {\n      return (\n        (direction & this.direction) === direction &&\n        velocityVector.isSimilar(\n          Vector.fromDirection(direction),\n          minimalAlignmentCosine\n        )\n      );\n    };\n\n    const axialDirectionsList = Object.values(Directions);\n    const diagonalDirectionsList = Object.values(DiagonalDirections);\n\n    // List of alignments to all activated directions\n    const axialAlignmentList = axialDirectionsList.map((direction) =>\n      getAlignment(direction, AXIAL_DEVIATION_COSINE)\n    );\n\n    const diagonalAlignmentList = diagonalDirectionsList.map((direction) =>\n      getAlignment(direction, DIAGONAL_DEVIATION_COSINE)\n    );\n\n    const isAligned =\n      axialAlignmentList.some(Boolean) || diagonalAlignmentList.some(Boolean);\n\n    const isFast = velocityVector.magnitude > this.minVelocity;\n\n    if (\n      this.maxNumberOfPointersSimultaneously ===\n        this.numberOfPointersRequired &&\n      isAligned &&\n      isFast\n    ) {\n      clearTimeout(this.delayTimeout);\n      this.activate();\n\n      return true;\n    }\n\n    return false;\n  }\n\n  private endFling() {\n    if (!this.tryEndFling()) {\n      this.fail();\n    }\n  }\n\n  protected onPointerDown(event: AdaptedEvent): void {\n    if (!this.isButtonInConfig(event.button)) {\n      return;\n    }\n\n    this.tracker.addToTracker(event);\n    this.keyPointer = event.pointerId;\n\n    super.onPointerDown(event);\n    this.newPointerAction();\n\n    this.tryToSendTouchEvent(event);\n  }\n\n  protected onPointerAdd(event: AdaptedEvent): void {\n    this.tracker.addToTracker(event);\n    super.onPointerAdd(event);\n    this.newPointerAction();\n  }\n\n  private newPointerAction(): void {\n    if (this.state === State.UNDETERMINED) {\n      this.startFling();\n    }\n\n    if (this.state !== State.BEGAN) {\n      return;\n    }\n\n    this.tryEndFling();\n\n    if (\n      this.tracker.trackedPointersCount > this.maxNumberOfPointersSimultaneously\n    ) {\n      this.maxNumberOfPointersSimultaneously =\n        this.tracker.trackedPointersCount;\n    }\n  }\n\n  private pointerMoveAction(event: AdaptedEvent): void {\n    this.tracker.track(event);\n\n    if (this.state !== State.BEGAN) {\n      return;\n    }\n\n    this.tryEndFling();\n  }\n\n  protected onPointerMove(event: AdaptedEvent): void {\n    this.pointerMoveAction(event);\n    super.onPointerMove(event);\n  }\n\n  protected onPointerOutOfBounds(event: AdaptedEvent): void {\n    this.pointerMoveAction(event);\n    super.onPointerOutOfBounds(event);\n  }\n\n  protected onPointerUp(event: AdaptedEvent): void {\n    super.onPointerUp(event);\n    this.onUp(event);\n\n    this.keyPointer = NaN;\n  }\n\n  protected onPointerRemove(event: AdaptedEvent): void {\n    super.onPointerRemove(event);\n    this.onUp(event);\n  }\n\n  private onUp(event: AdaptedEvent): void {\n    if (this.state === State.BEGAN) {\n      this.endFling();\n    }\n\n    this.tracker.removeFromTracker(event.pointerId);\n  }\n\n  public activate(force?: boolean): void {\n    super.activate(force);\n    this.end();\n  }\n\n  protected resetConfig(): void {\n    super.resetConfig();\n    this.numberOfPointersRequired = DEFAULT_NUMBER_OF_TOUCHES_REQUIRED;\n    this.direction = DEFAULT_DIRECTION;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}