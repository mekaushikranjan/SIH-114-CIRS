{"ast":null,"code":"\"use strict\";\n\nimport { State } from '../../State';\nimport GestureHandler from './GestureHandler';\nimport RotationGestureDetector from '../detectors/RotationGestureDetector';\nconst ROTATION_RECOGNITION_THRESHOLD = Math.PI / 36;\nexport default class RotationGestureHandler extends GestureHandler {\n  rotation = 0;\n  velocity = 0;\n  cachedAnchorX = 0;\n  cachedAnchorY = 0;\n  rotationGestureListener = {\n    onRotationBegin: _detector => true,\n    onRotation: detector => {\n      const previousRotation = this.rotation;\n      this.rotation += detector.rotation;\n      const delta = detector.timeDelta;\n      if (delta > 0) {\n        this.velocity = (this.rotation - previousRotation) / delta;\n      }\n      if (Math.abs(this.rotation) >= ROTATION_RECOGNITION_THRESHOLD && this.state === State.BEGAN) {\n        this.activate();\n      }\n      return true;\n    },\n    onRotationEnd: _detector => {\n      this.end();\n    }\n  };\n  rotationGestureDetector = new RotationGestureDetector(this.rotationGestureListener);\n  init(ref, propsRef) {\n    super.init(ref, propsRef);\n    this.shouldCancelWhenOutside = false;\n  }\n  transformNativeEvent() {\n    return {\n      rotation: this.rotation ? this.rotation : 0,\n      anchorX: this.getAnchorX(),\n      anchorY: this.getAnchorY(),\n      velocity: this.velocity ? this.velocity : 0\n    };\n  }\n  getAnchorX() {\n    const anchorX = this.rotationGestureDetector.anchorX;\n    return anchorX ? anchorX : this.cachedAnchorX;\n  }\n  getAnchorY() {\n    const anchorY = this.rotationGestureDetector.anchorY;\n    return anchorY ? anchorY : this.cachedAnchorY;\n  }\n  onPointerDown(event) {\n    this.tracker.addToTracker(event);\n    super.onPointerDown(event);\n    this.tryToSendTouchEvent(event);\n  }\n  onPointerAdd(event) {\n    this.tracker.addToTracker(event);\n    super.onPointerAdd(event);\n    this.tryBegin();\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n  }\n  onPointerMove(event) {\n    if (this.tracker.trackedPointersCount < 2) {\n      return;\n    }\n    if (this.getAnchorX()) {\n      this.cachedAnchorX = this.getAnchorX();\n    }\n    if (this.getAnchorY()) {\n      this.cachedAnchorY = this.getAnchorY();\n    }\n    this.tracker.track(event);\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n    super.onPointerMove(event);\n  }\n  onPointerOutOfBounds(event) {\n    if (this.tracker.trackedPointersCount < 2) {\n      return;\n    }\n    if (this.getAnchorX()) {\n      this.cachedAnchorX = this.getAnchorX();\n    }\n    if (this.getAnchorY()) {\n      this.cachedAnchorY = this.getAnchorY();\n    }\n    this.tracker.track(event);\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n    super.onPointerOutOfBounds(event);\n  }\n  onPointerUp(event) {\n    super.onPointerUp(event);\n    this.tracker.removeFromTracker(event.pointerId);\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n    if (this.state !== State.ACTIVE) {\n      return;\n    }\n    if (this.state === State.ACTIVE) {\n      this.end();\n    } else {\n      this.fail();\n    }\n  }\n  onPointerRemove(event) {\n    super.onPointerRemove(event);\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n    this.tracker.removeFromTracker(event.pointerId);\n  }\n  tryBegin() {\n    if (this.state !== State.UNDETERMINED) {\n      return;\n    }\n    this.begin();\n  }\n  onReset() {\n    if (this.state === State.ACTIVE) {\n      return;\n    }\n    this.rotation = 0;\n    this.velocity = 0;\n    this.rotationGestureDetector.reset();\n  }\n}","map":{"version":3,"names":["State","GestureHandler","RotationGestureDetector","ROTATION_RECOGNITION_THRESHOLD","Math","PI","RotationGestureHandler","rotation","velocity","cachedAnchorX","cachedAnchorY","rotationGestureListener","onRotationBegin","_detector","onRotation","detector","previousRotation","delta","timeDelta","abs","state","BEGAN","activate","onRotationEnd","end","rotationGestureDetector","init","ref","propsRef","shouldCancelWhenOutside","transformNativeEvent","anchorX","getAnchorX","anchorY","getAnchorY","onPointerDown","event","tracker","addToTracker","tryToSendTouchEvent","onPointerAdd","tryBegin","onTouchEvent","onPointerMove","trackedPointersCount","track","onPointerOutOfBounds","onPointerUp","removeFromTracker","pointerId","ACTIVE","fail","onPointerRemove","UNDETERMINED","begin","onReset","reset"],"sources":["C:\\Users\\prana\\OneDrive\\Desktop\\civic-reporter-sih\\frontend\\node_modules\\react-native-gesture-handler\\src\\web\\handlers\\RotationGestureHandler.ts"],"sourcesContent":["import { State } from '../../State';\nimport { AdaptedEvent } from '../interfaces';\n\nimport GestureHandler from './GestureHandler';\nimport RotationGestureDetector, {\n  RotationGestureListener,\n} from '../detectors/RotationGestureDetector';\n\nconst ROTATION_RECOGNITION_THRESHOLD = Math.PI / 36;\n\nexport default class RotationGestureHandler extends GestureHandler {\n  private rotation = 0;\n  private velocity = 0;\n\n  private cachedAnchorX = 0;\n  private cachedAnchorY = 0;\n\n  private rotationGestureListener: RotationGestureListener = {\n    onRotationBegin: (_detector: RotationGestureDetector): boolean => true,\n    onRotation: (detector: RotationGestureDetector): boolean => {\n      const previousRotation: number = this.rotation;\n      this.rotation += detector.rotation;\n\n      const delta = detector.timeDelta;\n\n      if (delta > 0) {\n        this.velocity = (this.rotation - previousRotation) / delta;\n      }\n\n      if (\n        Math.abs(this.rotation) >= ROTATION_RECOGNITION_THRESHOLD &&\n        this.state === State.BEGAN\n      ) {\n        this.activate();\n      }\n\n      return true;\n    },\n    onRotationEnd: (_detector: RotationGestureDetector): void => {\n      this.end();\n    },\n  };\n\n  private rotationGestureDetector: RotationGestureDetector =\n    new RotationGestureDetector(this.rotationGestureListener);\n\n  public init(ref: number, propsRef: React.RefObject<unknown>): void {\n    super.init(ref, propsRef);\n\n    this.shouldCancelWhenOutside = false;\n  }\n\n  protected transformNativeEvent() {\n    return {\n      rotation: this.rotation ? this.rotation : 0,\n      anchorX: this.getAnchorX(),\n      anchorY: this.getAnchorY(),\n      velocity: this.velocity ? this.velocity : 0,\n    };\n  }\n\n  public getAnchorX(): number {\n    const anchorX = this.rotationGestureDetector.anchorX;\n\n    return anchorX ? anchorX : this.cachedAnchorX;\n  }\n\n  public getAnchorY(): number {\n    const anchorY = this.rotationGestureDetector.anchorY;\n\n    return anchorY ? anchorY : this.cachedAnchorY;\n  }\n\n  protected onPointerDown(event: AdaptedEvent): void {\n    this.tracker.addToTracker(event);\n    super.onPointerDown(event);\n\n    this.tryToSendTouchEvent(event);\n  }\n\n  protected onPointerAdd(event: AdaptedEvent): void {\n    this.tracker.addToTracker(event);\n    super.onPointerAdd(event);\n\n    this.tryBegin();\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n  }\n\n  protected onPointerMove(event: AdaptedEvent): void {\n    if (this.tracker.trackedPointersCount < 2) {\n      return;\n    }\n\n    if (this.getAnchorX()) {\n      this.cachedAnchorX = this.getAnchorX();\n    }\n    if (this.getAnchorY()) {\n      this.cachedAnchorY = this.getAnchorY();\n    }\n\n    this.tracker.track(event);\n\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n\n    super.onPointerMove(event);\n  }\n\n  protected onPointerOutOfBounds(event: AdaptedEvent): void {\n    if (this.tracker.trackedPointersCount < 2) {\n      return;\n    }\n\n    if (this.getAnchorX()) {\n      this.cachedAnchorX = this.getAnchorX();\n    }\n    if (this.getAnchorY()) {\n      this.cachedAnchorY = this.getAnchorY();\n    }\n\n    this.tracker.track(event);\n\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n\n    super.onPointerOutOfBounds(event);\n  }\n\n  protected onPointerUp(event: AdaptedEvent): void {\n    super.onPointerUp(event);\n    this.tracker.removeFromTracker(event.pointerId);\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n\n    if (this.state !== State.ACTIVE) {\n      return;\n    }\n\n    if (this.state === State.ACTIVE) {\n      this.end();\n    } else {\n      this.fail();\n    }\n  }\n\n  protected onPointerRemove(event: AdaptedEvent): void {\n    super.onPointerRemove(event);\n    this.rotationGestureDetector.onTouchEvent(event, this.tracker);\n    this.tracker.removeFromTracker(event.pointerId);\n  }\n\n  protected tryBegin(): void {\n    if (this.state !== State.UNDETERMINED) {\n      return;\n    }\n\n    this.begin();\n  }\n\n  protected onReset(): void {\n    if (this.state === State.ACTIVE) {\n      return;\n    }\n\n    this.rotation = 0;\n    this.velocity = 0;\n    this.rotationGestureDetector.reset();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}