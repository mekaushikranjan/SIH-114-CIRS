{"ast":null,"code":"import AsyncStorage from '@react-native-async-storage/async-storage';\nclass TimeTrackingService {\n  activeTimers = new Map();\n  STORAGE_KEY = 'worker_time_entries';\n  async startTimeTracking(assignmentId, issueId, workerId, location) {\n    const timeEntry = {\n      id: `time_${Date.now()}`,\n      assignmentId,\n      issueId,\n      workerId,\n      startTime: new Date().toISOString(),\n      status: 'active',\n      pausedDuration: 0,\n      breaks: [],\n      location,\n      notes: []\n    };\n    await this.saveTimeEntry(timeEntry);\n    this.startTimer(timeEntry.id);\n    console.log(`⏱️ Time tracking started for assignment: ${assignmentId}`);\n    return timeEntry;\n  }\n  async pauseTimeTracking(timeEntryId, reason = 'Break') {\n    const timeEntry = await this.getTimeEntry(timeEntryId);\n    if (!timeEntry || timeEntry.status !== 'active') {\n      return null;\n    }\n    const breakEntry = {\n      id: `break_${Date.now()}`,\n      startTime: new Date().toISOString(),\n      reason\n    };\n    timeEntry.status = 'paused';\n    timeEntry.breaks.push(breakEntry);\n    timeEntry.notes.push(`Work paused: ${reason} at ${new Date().toLocaleTimeString()}`);\n    this.stopTimer(timeEntryId);\n    await this.saveTimeEntry(timeEntry);\n    console.log(`⏸️ Time tracking paused for: ${reason}`);\n    return timeEntry;\n  }\n  async resumeTimeTracking(timeEntryId) {\n    const timeEntry = await this.getTimeEntry(timeEntryId);\n    if (!timeEntry || timeEntry.status !== 'paused') {\n      return null;\n    }\n    const currentBreak = timeEntry.breaks[timeEntry.breaks.length - 1];\n    if (currentBreak && !currentBreak.endTime) {\n      currentBreak.endTime = new Date().toISOString();\n      currentBreak.duration = this.calculateDuration(currentBreak.startTime, currentBreak.endTime);\n      timeEntry.pausedDuration += currentBreak.duration;\n    }\n    timeEntry.status = 'active';\n    timeEntry.notes.push(`Work resumed at ${new Date().toLocaleTimeString()}`);\n    this.startTimer(timeEntryId);\n    await this.saveTimeEntry(timeEntry);\n    console.log(`▶️ Time tracking resumed`);\n    return timeEntry;\n  }\n  async completeTimeTracking(timeEntryId, notes) {\n    const timeEntry = await this.getTimeEntry(timeEntryId);\n    if (!timeEntry) {\n      return null;\n    }\n    const currentBreak = timeEntry.breaks[timeEntry.breaks.length - 1];\n    if (currentBreak && !currentBreak.endTime) {\n      currentBreak.endTime = new Date().toISOString();\n      currentBreak.duration = this.calculateDuration(currentBreak.startTime, currentBreak.endTime);\n      timeEntry.pausedDuration += currentBreak.duration;\n    }\n    timeEntry.endTime = new Date().toISOString();\n    timeEntry.duration = this.calculateDuration(timeEntry.startTime, timeEntry.endTime);\n    timeEntry.status = 'completed';\n    if (notes) {\n      timeEntry.notes.push(`Work completed: ${notes}`);\n    }\n    this.stopTimer(timeEntryId);\n    await this.saveTimeEntry(timeEntry);\n    console.log(`✅ Time tracking completed. Duration: ${this.formatDuration(timeEntry.duration)}`);\n    return timeEntry;\n  }\n  async addNote(timeEntryId, note) {\n    const timeEntry = await this.getTimeEntry(timeEntryId);\n    if (!timeEntry) {\n      return false;\n    }\n    timeEntry.notes.push(`${new Date().toLocaleTimeString()}: ${note}`);\n    await this.saveTimeEntry(timeEntry);\n    return true;\n  }\n  async getActiveTimeEntry(workerId) {\n    const entries = await this.getAllTimeEntries();\n    return entries.find(entry => entry.workerId === workerId && (entry.status === 'active' || entry.status === 'paused')) || null;\n  }\n  async getTimeEntry(timeEntryId) {\n    const entries = await this.getAllTimeEntries();\n    return entries.find(entry => entry.id === timeEntryId) || null;\n  }\n  async getWorkerTimeEntries(workerId) {\n    const entries = await this.getAllTimeEntries();\n    return entries.filter(entry => entry.workerId === workerId);\n  }\n  async getAssignmentTimeEntries(assignmentId) {\n    const entries = await this.getAllTimeEntries();\n    return entries.filter(entry => entry.assignmentId === assignmentId);\n  }\n  async getTimeTrackingStats(workerId, dateRange) {\n    let entries = await this.getWorkerTimeEntries(workerId);\n    if (dateRange) {\n      entries = entries.filter(entry => {\n        const entryDate = new Date(entry.startTime);\n        const startDate = new Date(dateRange.start);\n        const endDate = new Date(dateRange.end);\n        return entryDate >= startDate && entryDate <= endDate;\n      });\n    }\n    const completedEntries = entries.filter(entry => entry.status === 'completed');\n    const totalWorkTime = completedEntries.reduce((total, entry) => {\n      return total + (entry.duration || 0) - entry.pausedDuration;\n    }, 0);\n    const totalBreakTime = completedEntries.reduce((total, entry) => {\n      return total + entry.pausedDuration;\n    }, 0);\n    const totalTime = totalWorkTime + totalBreakTime;\n    const efficiency = totalTime > 0 ? totalWorkTime / totalTime * 100 : 0;\n    const averageWorkDuration = completedEntries.length > 0 ? totalWorkTime / completedEntries.length : 0;\n    return {\n      totalWorkTime,\n      totalBreakTime,\n      averageWorkDuration,\n      completedSessions: completedEntries.length,\n      efficiency\n    };\n  }\n  getCurrentDuration(timeEntry) {\n    if (!timeEntry.startTime) return 0;\n    const startTime = new Date(timeEntry.startTime);\n    const currentTime = new Date();\n    const totalMinutes = Math.floor((currentTime.getTime() - startTime.getTime()) / (1000 * 60));\n    let pausedTime = timeEntry.pausedDuration;\n    if (timeEntry.status === 'paused') {\n      const currentBreak = timeEntry.breaks[timeEntry.breaks.length - 1];\n      if (currentBreak && !currentBreak.endTime) {\n        const breakDuration = this.calculateDuration(currentBreak.startTime, new Date().toISOString());\n        pausedTime += breakDuration;\n      }\n    }\n    return Math.max(0, totalMinutes - pausedTime);\n  }\n  formatDuration(minutes) {\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    if (hours > 0) {\n      return `${hours}h ${mins}m`;\n    }\n    return `${mins}m`;\n  }\n  formatDurationWithSeconds(minutes) {\n    const hours = Math.floor(minutes / 60);\n    const mins = Math.floor(minutes % 60);\n    const seconds = Math.floor(minutes % 1 * 60);\n    if (hours > 0) {\n      return `${hours}:${mins.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n    }\n    return `${mins}:${seconds.toString().padStart(2, '0')}`;\n  }\n  async exportTimeEntries(workerId, dateRange) {\n    let entries = await this.getWorkerTimeEntries(workerId);\n    if (dateRange) {\n      entries = entries.filter(entry => {\n        const entryDate = new Date(entry.startTime);\n        const startDate = new Date(dateRange.start);\n        const endDate = new Date(dateRange.end);\n        return entryDate >= startDate && entryDate <= endDate;\n      });\n    }\n    const csvHeader = 'Date,Assignment ID,Issue ID,Start Time,End Time,Duration (minutes),Break Time (minutes),Status,Notes\\n';\n    const csvRows = entries.map(entry => {\n      const date = new Date(entry.startTime).toLocaleDateString();\n      const startTime = new Date(entry.startTime).toLocaleTimeString();\n      const endTime = entry.endTime ? new Date(entry.endTime).toLocaleTimeString() : '';\n      const duration = entry.duration || 0;\n      const breakTime = entry.pausedDuration;\n      const notes = entry.notes.join('; ').replace(/,/g, ';');\n      return `${date},${entry.assignmentId},${entry.issueId},${startTime},${endTime},${duration},${breakTime},${entry.status},\"${notes}\"`;\n    }).join('\\n');\n    return csvHeader + csvRows;\n  }\n  startTimer(timeEntryId) {\n    this.stopTimer(timeEntryId);\n    const timer = setInterval(async () => {\n      const timeEntry = await this.getTimeEntry(timeEntryId);\n      if (timeEntry && timeEntry.status === 'active') {\n        console.log(`⏱️ Active work time: ${this.formatDuration(this.getCurrentDuration(timeEntry))}`);\n      } else {\n        this.stopTimer(timeEntryId);\n      }\n    }, 60000);\n    this.activeTimers.set(timeEntryId, timer);\n  }\n  stopTimer(timeEntryId) {\n    const timer = this.activeTimers.get(timeEntryId);\n    if (timer) {\n      clearInterval(timer);\n      this.activeTimers.delete(timeEntryId);\n    }\n  }\n  calculateDuration(startTime, endTime) {\n    const start = new Date(startTime);\n    const end = new Date(endTime);\n    return Math.floor((end.getTime() - start.getTime()) / (1000 * 60));\n  }\n  async saveTimeEntry(timeEntry) {\n    try {\n      const entries = await this.getAllTimeEntries();\n      const existingIndex = entries.findIndex(entry => entry.id === timeEntry.id);\n      if (existingIndex >= 0) {\n        entries[existingIndex] = timeEntry;\n      } else {\n        entries.push(timeEntry);\n      }\n      await AsyncStorage.setItem(this.STORAGE_KEY, JSON.stringify(entries));\n    } catch (error) {\n      console.error('Error saving time entry:', error);\n    }\n  }\n  async getAllTimeEntries() {\n    try {\n      const data = await AsyncStorage.getItem(this.STORAGE_KEY);\n      return data ? JSON.parse(data) : [];\n    } catch (error) {\n      console.error('Error loading time entries:', error);\n      return [];\n    }\n  }\n  async clearAllTimeEntries() {\n    try {\n      await AsyncStorage.removeItem(this.STORAGE_KEY);\n      this.activeTimers.forEach(timer => clearInterval(timer));\n      this.activeTimers.clear();\n      console.log('All time entries cleared');\n    } catch (error) {\n      console.error('Error clearing time entries:', error);\n    }\n  }\n}\nexport const timeTrackingService = new TimeTrackingService();\nexport default timeTrackingService;","map":{"version":3,"names":["AsyncStorage","TimeTrackingService","activeTimers","Map","STORAGE_KEY","startTimeTracking","assignmentId","issueId","workerId","location","timeEntry","id","Date","now","startTime","toISOString","status","pausedDuration","breaks","notes","saveTimeEntry","startTimer","console","log","pauseTimeTracking","timeEntryId","reason","getTimeEntry","breakEntry","push","toLocaleTimeString","stopTimer","resumeTimeTracking","currentBreak","length","endTime","duration","calculateDuration","completeTimeTracking","formatDuration","addNote","note","getActiveTimeEntry","entries","getAllTimeEntries","find","entry","getWorkerTimeEntries","filter","getAssignmentTimeEntries","getTimeTrackingStats","dateRange","entryDate","startDate","start","endDate","end","completedEntries","totalWorkTime","reduce","total","totalBreakTime","totalTime","efficiency","averageWorkDuration","completedSessions","getCurrentDuration","currentTime","totalMinutes","Math","floor","getTime","pausedTime","breakDuration","max","minutes","hours","mins","formatDurationWithSeconds","seconds","toString","padStart","exportTimeEntries","csvHeader","csvRows","map","date","toLocaleDateString","breakTime","join","replace","timer","setInterval","set","get","clearInterval","delete","existingIndex","findIndex","setItem","JSON","stringify","error","data","getItem","parse","clearAllTimeEntries","removeItem","forEach","clear","timeTrackingService"],"sources":["C:/Users/prana/OneDrive/Desktop/civic-reporter-sih/frontend/src/services/timeTrackingService.ts"],"sourcesContent":["import AsyncStorage from '@react-native-async-storage/async-storage';\n\nexport interface TimeEntry {\n  id: string;\n  assignmentId: string;\n  issueId: string;\n  workerId: string;\n  startTime: string;\n  endTime?: string;\n  duration?: number; // in minutes\n  status: 'active' | 'paused' | 'completed';\n  pausedDuration: number; // total paused time in minutes\n  breaks: Array<{\n    id: string;\n    startTime: string;\n    endTime?: string;\n    reason: string;\n    duration?: number;\n  }>;\n  location?: {\n    latitude: number;\n    longitude: number;\n    address?: string;\n  };\n  notes: string[];\n}\n\nexport interface TimeTrackingStats {\n  totalWorkTime: number; // in minutes\n  totalBreakTime: number; // in minutes\n  averageWorkDuration: number; // in minutes\n  completedSessions: number;\n  efficiency: number; // percentage (work time / total time)\n}\n\nclass TimeTrackingService {\n  private activeTimers: Map<string, NodeJS.Timeout> = new Map();\n  private readonly STORAGE_KEY = 'worker_time_entries';\n\n  /**\n   * Start time tracking for an assignment\n   */\n  async startTimeTracking(\n    assignmentId: string,\n    issueId: string,\n    workerId: string,\n    location?: any\n  ): Promise<TimeEntry> {\n    const timeEntry: TimeEntry = {\n      id: `time_${Date.now()}`,\n      assignmentId,\n      issueId,\n      workerId,\n      startTime: new Date().toISOString(),\n      status: 'active',\n      pausedDuration: 0,\n      breaks: [],\n      location,\n      notes: [],\n    };\n\n    // Save to storage\n    await this.saveTimeEntry(timeEntry);\n\n    // Start timer for real-time updates\n    this.startTimer(timeEntry.id);\n\n    console.log(`⏱️ Time tracking started for assignment: ${assignmentId}`);\n    return timeEntry;\n  }\n\n  /**\n   * Pause time tracking\n   */\n  async pauseTimeTracking(\n    timeEntryId: string,\n    reason: string = 'Break'\n  ): Promise<TimeEntry | null> {\n    const timeEntry = await this.getTimeEntry(timeEntryId);\n    if (!timeEntry || timeEntry.status !== 'active') {\n      return null;\n    }\n\n    const breakEntry = {\n      id: `break_${Date.now()}`,\n      startTime: new Date().toISOString(),\n      reason,\n    };\n\n    timeEntry.status = 'paused';\n    timeEntry.breaks.push(breakEntry);\n    timeEntry.notes.push(`Work paused: ${reason} at ${new Date().toLocaleTimeString()}`);\n\n    // Stop the active timer\n    this.stopTimer(timeEntryId);\n\n    await this.saveTimeEntry(timeEntry);\n    console.log(`⏸️ Time tracking paused for: ${reason}`);\n    return timeEntry;\n  }\n\n  /**\n   * Resume time tracking\n   */\n  async resumeTimeTracking(timeEntryId: string): Promise<TimeEntry | null> {\n    const timeEntry = await this.getTimeEntry(timeEntryId);\n    if (!timeEntry || timeEntry.status !== 'paused') {\n      return null;\n    }\n\n    // End the current break\n    const currentBreak = timeEntry.breaks[timeEntry.breaks.length - 1];\n    if (currentBreak && !currentBreak.endTime) {\n      currentBreak.endTime = new Date().toISOString();\n      currentBreak.duration = this.calculateDuration(currentBreak.startTime, currentBreak.endTime);\n      \n      // Add to total paused duration\n      timeEntry.pausedDuration += currentBreak.duration;\n    }\n\n    timeEntry.status = 'active';\n    timeEntry.notes.push(`Work resumed at ${new Date().toLocaleTimeString()}`);\n\n    // Restart timer\n    this.startTimer(timeEntryId);\n\n    await this.saveTimeEntry(timeEntry);\n    console.log(`▶️ Time tracking resumed`);\n    return timeEntry;\n  }\n\n  /**\n   * Complete time tracking\n   */\n  async completeTimeTracking(\n    timeEntryId: string,\n    notes?: string\n  ): Promise<TimeEntry | null> {\n    const timeEntry = await this.getTimeEntry(timeEntryId);\n    if (!timeEntry) {\n      return null;\n    }\n\n    // End any active break\n    const currentBreak = timeEntry.breaks[timeEntry.breaks.length - 1];\n    if (currentBreak && !currentBreak.endTime) {\n      currentBreak.endTime = new Date().toISOString();\n      currentBreak.duration = this.calculateDuration(currentBreak.startTime, currentBreak.endTime);\n      timeEntry.pausedDuration += currentBreak.duration;\n    }\n\n    timeEntry.endTime = new Date().toISOString();\n    timeEntry.duration = this.calculateDuration(timeEntry.startTime, timeEntry.endTime);\n    timeEntry.status = 'completed';\n\n    if (notes) {\n      timeEntry.notes.push(`Work completed: ${notes}`);\n    }\n\n    // Stop timer\n    this.stopTimer(timeEntryId);\n\n    await this.saveTimeEntry(timeEntry);\n    console.log(`✅ Time tracking completed. Duration: ${this.formatDuration(timeEntry.duration)}`);\n    return timeEntry;\n  }\n\n  /**\n   * Add a note to time entry\n   */\n  async addNote(timeEntryId: string, note: string): Promise<boolean> {\n    const timeEntry = await this.getTimeEntry(timeEntryId);\n    if (!timeEntry) {\n      return false;\n    }\n\n    timeEntry.notes.push(`${new Date().toLocaleTimeString()}: ${note}`);\n    await this.saveTimeEntry(timeEntry);\n    return true;\n  }\n\n  /**\n   * Get current active time entry for a worker\n   */\n  async getActiveTimeEntry(workerId: string): Promise<TimeEntry | null> {\n    const entries = await this.getAllTimeEntries();\n    return entries.find(entry => \n      entry.workerId === workerId && \n      (entry.status === 'active' || entry.status === 'paused')\n    ) || null;\n  }\n\n  /**\n   * Get time entry by ID\n   */\n  async getTimeEntry(timeEntryId: string): Promise<TimeEntry | null> {\n    const entries = await this.getAllTimeEntries();\n    return entries.find(entry => entry.id === timeEntryId) || null;\n  }\n\n  /**\n   * Get all time entries for a worker\n   */\n  async getWorkerTimeEntries(workerId: string): Promise<TimeEntry[]> {\n    const entries = await this.getAllTimeEntries();\n    return entries.filter(entry => entry.workerId === workerId);\n  }\n\n  /**\n   * Get time entries for a specific assignment\n   */\n  async getAssignmentTimeEntries(assignmentId: string): Promise<TimeEntry[]> {\n    const entries = await this.getAllTimeEntries();\n    return entries.filter(entry => entry.assignmentId === assignmentId);\n  }\n\n  /**\n   * Calculate time tracking statistics for a worker\n   */\n  async getTimeTrackingStats(workerId: string, dateRange?: { start: string; end: string }): Promise<TimeTrackingStats> {\n    let entries = await this.getWorkerTimeEntries(workerId);\n    \n    // Filter by date range if provided\n    if (dateRange) {\n      entries = entries.filter(entry => {\n        const entryDate = new Date(entry.startTime);\n        const startDate = new Date(dateRange.start);\n        const endDate = new Date(dateRange.end);\n        return entryDate >= startDate && entryDate <= endDate;\n      });\n    }\n\n    const completedEntries = entries.filter(entry => entry.status === 'completed');\n    \n    const totalWorkTime = completedEntries.reduce((total, entry) => {\n      return total + (entry.duration || 0) - entry.pausedDuration;\n    }, 0);\n\n    const totalBreakTime = completedEntries.reduce((total, entry) => {\n      return total + entry.pausedDuration;\n    }, 0);\n\n    const totalTime = totalWorkTime + totalBreakTime;\n    const efficiency = totalTime > 0 ? (totalWorkTime / totalTime) * 100 : 0;\n    const averageWorkDuration = completedEntries.length > 0 ? totalWorkTime / completedEntries.length : 0;\n\n    return {\n      totalWorkTime,\n      totalBreakTime,\n      averageWorkDuration,\n      completedSessions: completedEntries.length,\n      efficiency,\n    };\n  }\n\n  /**\n   * Get real-time duration for active time entry\n   */\n  getCurrentDuration(timeEntry: TimeEntry): number {\n    if (!timeEntry.startTime) return 0;\n\n    const startTime = new Date(timeEntry.startTime);\n    const currentTime = new Date();\n    const totalMinutes = Math.floor((currentTime.getTime() - startTime.getTime()) / (1000 * 60));\n\n    // Subtract paused time and current break time if paused\n    let pausedTime = timeEntry.pausedDuration;\n    \n    if (timeEntry.status === 'paused') {\n      const currentBreak = timeEntry.breaks[timeEntry.breaks.length - 1];\n      if (currentBreak && !currentBreak.endTime) {\n        const breakDuration = this.calculateDuration(currentBreak.startTime, new Date().toISOString());\n        pausedTime += breakDuration;\n      }\n    }\n\n    return Math.max(0, totalMinutes - pausedTime);\n  }\n\n  /**\n   * Format duration for display\n   */\n  formatDuration(minutes: number): string {\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    \n    if (hours > 0) {\n      return `${hours}h ${mins}m`;\n    }\n    return `${mins}m`;\n  }\n\n  /**\n   * Format duration with seconds for real-time display\n   */\n  formatDurationWithSeconds(minutes: number): string {\n    const hours = Math.floor(minutes / 60);\n    const mins = Math.floor(minutes % 60);\n    const seconds = Math.floor((minutes % 1) * 60);\n    \n    if (hours > 0) {\n      return `${hours}:${mins.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n    }\n    return `${mins}:${seconds.toString().padStart(2, '0')}`;\n  }\n\n  /**\n   * Export time entries to CSV format\n   */\n  async exportTimeEntries(workerId: string, dateRange?: { start: string; end: string }): Promise<string> {\n    let entries = await this.getWorkerTimeEntries(workerId);\n    \n    if (dateRange) {\n      entries = entries.filter(entry => {\n        const entryDate = new Date(entry.startTime);\n        const startDate = new Date(dateRange.start);\n        const endDate = new Date(dateRange.end);\n        return entryDate >= startDate && entryDate <= endDate;\n      });\n    }\n\n    const csvHeader = 'Date,Assignment ID,Issue ID,Start Time,End Time,Duration (minutes),Break Time (minutes),Status,Notes\\n';\n    \n    const csvRows = entries.map(entry => {\n      const date = new Date(entry.startTime).toLocaleDateString();\n      const startTime = new Date(entry.startTime).toLocaleTimeString();\n      const endTime = entry.endTime ? new Date(entry.endTime).toLocaleTimeString() : '';\n      const duration = entry.duration || 0;\n      const breakTime = entry.pausedDuration;\n      const notes = entry.notes.join('; ').replace(/,/g, ';');\n      \n      return `${date},${entry.assignmentId},${entry.issueId},${startTime},${endTime},${duration},${breakTime},${entry.status},\"${notes}\"`;\n    }).join('\\n');\n\n    return csvHeader + csvRows;\n  }\n\n  /**\n   * Private methods\n   */\n  private startTimer(timeEntryId: string): void {\n    // Clear existing timer\n    this.stopTimer(timeEntryId);\n\n    // Start new timer that updates every minute\n    const timer = setInterval(async () => {\n      const timeEntry = await this.getTimeEntry(timeEntryId);\n      if (timeEntry && timeEntry.status === 'active') {\n        // Timer is running, could trigger UI updates here\n        console.log(`⏱️ Active work time: ${this.formatDuration(this.getCurrentDuration(timeEntry))}`);\n      } else {\n        // Stop timer if entry is no longer active\n        this.stopTimer(timeEntryId);\n      }\n    }, 60000); // Update every minute\n\n    this.activeTimers.set(timeEntryId, timer);\n  }\n\n  private stopTimer(timeEntryId: string): void {\n    const timer = this.activeTimers.get(timeEntryId);\n    if (timer) {\n      clearInterval(timer);\n      this.activeTimers.delete(timeEntryId);\n    }\n  }\n\n  private calculateDuration(startTime: string, endTime: string): number {\n    const start = new Date(startTime);\n    const end = new Date(endTime);\n    return Math.floor((end.getTime() - start.getTime()) / (1000 * 60));\n  }\n\n  private async saveTimeEntry(timeEntry: TimeEntry): Promise<void> {\n    try {\n      const entries = await this.getAllTimeEntries();\n      const existingIndex = entries.findIndex(entry => entry.id === timeEntry.id);\n      \n      if (existingIndex >= 0) {\n        entries[existingIndex] = timeEntry;\n      } else {\n        entries.push(timeEntry);\n      }\n\n      await AsyncStorage.setItem(this.STORAGE_KEY, JSON.stringify(entries));\n    } catch (error) {\n      console.error('Error saving time entry:', error);\n    }\n  }\n\n  private async getAllTimeEntries(): Promise<TimeEntry[]> {\n    try {\n      const data = await AsyncStorage.getItem(this.STORAGE_KEY);\n      return data ? JSON.parse(data) : [];\n    } catch (error) {\n      console.error('Error loading time entries:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Clear all time entries (for testing/reset)\n   */\n  async clearAllTimeEntries(): Promise<void> {\n    try {\n      await AsyncStorage.removeItem(this.STORAGE_KEY);\n      // Clear all active timers\n      this.activeTimers.forEach(timer => clearInterval(timer));\n      this.activeTimers.clear();\n      console.log('All time entries cleared');\n    } catch (error) {\n      console.error('Error clearing time entries:', error);\n    }\n  }\n}\n\nexport const timeTrackingService = new TimeTrackingService();\nexport default timeTrackingService;\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}