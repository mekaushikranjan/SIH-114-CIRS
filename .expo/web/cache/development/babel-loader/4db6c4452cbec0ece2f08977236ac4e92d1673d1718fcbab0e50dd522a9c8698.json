{"ast":null,"code":"'use strict';\n\nimport { logger, ReanimatedError } from \"../../common/index.js\";\nimport { PERCENTAGE_REGEX } from \"../constants/index.js\";\nexport const ERROR_MESSAGES = {\n  invalidPointsCount: () => `Invalid linear easing points count. There should be at least two points`,\n  invalidInputProgressValue: inputProgress => `Invalid input progress ${inputProgress} value, it should be a percentage between 0% and 100%`\n};\nexport const WARN_MESSAGES = {\n  inputProgressLessThanPrecedingPoint: (x, precedingX) => `Linear easing point x value ${x} is less than value of the preceding control point ${precedingX}. Value will be overridden by ${precedingX}`\n};\nconst parsePercentage = percentage => {\n  let result;\n  if (typeof percentage === 'number') {\n    result = percentage;\n  } else if (PERCENTAGE_REGEX.test(percentage)) {\n    result = parseFloat(percentage) / 100;\n  }\n  if (result === undefined || result < 0 || result > 1) {\n    throw new ReanimatedError(ERROR_MESSAGES.invalidInputProgressValue(percentage));\n  }\n  return result;\n};\nconst extrapolate = (x, point1, point2) => {\n  const slope = (point2.y - point1.y) / (point2.x - point1.x);\n  return point1.y + slope * (x - point1.x);\n};\nexport class LinearEasing {\n  static easingName = 'linear';\n  constructor(points) {\n    if (points.length < 2) {\n      throw new ReanimatedError(ERROR_MESSAGES.invalidPointsCount());\n    }\n    this.points = points.map(p => Array.isArray(p) && p.length === 1 ? p[0] : p);\n  }\n  toString() {\n    return `${LinearEasing.easingName}(${this.points.map(point => Array.isArray(point) ? `[${point.map(p => typeof p === 'string' ? `\"${p}\"` : p).join(', ')}]` : point).join(', ')})`;\n  }\n  normalize() {\n    const points = this.canonicalize();\n    if (points[0].x > 0) {\n      points.unshift({\n        x: 0,\n        y: extrapolate(0, points[0], points[1])\n      });\n    }\n    if (points[points.length - 1].x < 1) {\n      points.push({\n        x: 1,\n        y: extrapolate(1, points[points.length - 2], points[points.length - 1])\n      });\n    }\n    return {\n      name: LinearEasing.easingName,\n      points\n    };\n  }\n  canonicalize() {\n    const result = this.points.flatMap(point => Array.isArray(point) ? point.slice(1).map(x => ({\n      x: parsePercentage(x),\n      y: point[0]\n    })) : [{\n      y: point\n    }]);\n    if (result[0].x === undefined) {\n      result[0].x = 0;\n    }\n    if (result[result.length - 1].x === undefined) {\n      result[result.length - 1].x = 1;\n    }\n    let maxPrecedingX = 0;\n    for (let i = 1; i < result.length - 1; i++) {\n      const x = result[i].x;\n      if (x !== undefined) {\n        if (x < maxPrecedingX) {\n          logger.warn(WARN_MESSAGES.inputProgressLessThanPrecedingPoint(x, maxPrecedingX));\n          result[i].x = maxPrecedingX;\n        } else {\n          maxPrecedingX = x;\n        }\n      }\n    }\n    let precedingX = result[0].x;\n    let missingCount = 0;\n    for (let i = 1; i < result.length; i++) {\n      const x = result[i].x;\n      if (x === undefined) {\n        missingCount++;\n        continue;\n      }\n      if (missingCount > 0) {\n        const range = x - precedingX;\n        for (let j = 0; j < missingCount; j++) {\n          result[i - missingCount + j].x = precedingX + range * (j + 1) / (missingCount + 1);\n        }\n      }\n      precedingX = x;\n      missingCount = 0;\n    }\n    return result;\n  }\n}","map":{"version":3,"names":["logger","ReanimatedError","PERCENTAGE_REGEX","ERROR_MESSAGES","invalidPointsCount","invalidInputProgressValue","inputProgress","WARN_MESSAGES","inputProgressLessThanPrecedingPoint","x","precedingX","parsePercentage","percentage","result","test","parseFloat","undefined","extrapolate","point1","point2","slope","y","LinearEasing","easingName","constructor","points","length","map","p","Array","isArray","toString","point","join","normalize","canonicalize","unshift","push","name","flatMap","slice","maxPrecedingX","i","warn","missingCount","range","j"],"sources":["C:\\Users\\prana\\OneDrive\\Desktop\\civic-reporter-sih\\frontend\\node_modules\\react-native-reanimated\\src\\css\\easing\\linear.ts"],"sourcesContent":["'use strict';\nimport { logger, ReanimatedError } from '../../common';\nimport { PERCENTAGE_REGEX } from '../constants';\nimport type { Point } from '../types';\nimport type {\n  ControlPoint,\n  NormalizedLinearEasing,\n  ParametrizedTimingFunction,\n} from './types';\n\nexport const ERROR_MESSAGES = {\n  invalidPointsCount: () =>\n    `Invalid linear easing points count. There should be at least two points`,\n  invalidInputProgressValue: (inputProgress: string | number) =>\n    `Invalid input progress ${inputProgress} value, it should be a percentage between 0% and 100%`,\n};\n\nexport const WARN_MESSAGES = {\n  inputProgressLessThanPrecedingPoint: (x: number, precedingX: number) =>\n    `Linear easing point x value ${x} is less than value of the preceding control point ${precedingX}. Value will be overridden by ${precedingX}`,\n};\n\nconst parsePercentage = (percentage: string | number): number => {\n  let result: number | undefined;\n  if (typeof percentage === 'number') {\n    result = percentage;\n  } else if (PERCENTAGE_REGEX.test(percentage)) {\n    result = parseFloat(percentage) / 100;\n  }\n\n  if (result === undefined || result < 0 || result > 1) {\n    throw new ReanimatedError(\n      ERROR_MESSAGES.invalidInputProgressValue(percentage)\n    );\n  }\n\n  return result;\n};\n\nconst extrapolate = (x: number, point1: Point, point2: Point) => {\n  const slope = (point2.y - point1.y) / (point2.x - point1.x);\n  return point1.y + slope * (x - point1.x);\n};\n\nexport class LinearEasing implements ParametrizedTimingFunction {\n  static readonly easingName = 'linear';\n  readonly points: ControlPoint[];\n\n  constructor(points: ControlPoint[]) {\n    if (points.length < 2) {\n      throw new ReanimatedError(ERROR_MESSAGES.invalidPointsCount());\n    }\n    this.points = points.map((p) =>\n      Array.isArray(p) && p.length === 1 ? p[0] : p\n    );\n  }\n\n  toString(): string {\n    return `${LinearEasing.easingName}(${this.points\n      .map((point) =>\n        Array.isArray(point)\n          ? `[${point.map((p) => (typeof p === 'string' ? `\"${p}\"` : p)).join(', ')}]`\n          : point\n      )\n      .join(', ')})`;\n  }\n\n  normalize(): NormalizedLinearEasing {\n    const points = this.canonicalize();\n\n    // Extrapolate points if the input progress of the first one is greater than 0\n    // or the input progress of the last one is less than 1\n    if (points[0].x > 0) {\n      points.unshift({ x: 0, y: extrapolate(0, points[0], points[1]) });\n    }\n    if (points[points.length - 1].x < 1) {\n      points.push({\n        x: 1,\n        y: extrapolate(1, points[points.length - 2], points[points.length - 1]),\n      });\n    }\n\n    return { name: LinearEasing.easingName, points };\n  }\n\n  private canonicalize() {\n    const result = this.points.flatMap<{ x?: number; y: number }>((point) =>\n      Array.isArray(point)\n        ? point.slice(1).map((x) => ({ x: parsePercentage(x), y: point[0] }))\n        : [{ y: point }]\n    );\n\n    // 1. If the first control point lacks an input progress value,\n    // set its input progress value to 0.\n    if (result[0].x === undefined) {\n      result[0].x = 0;\n    }\n\n    // 2.If the last control point lacks an input progress value,\n    // set its input progress value to 1.\n    if (result[result.length - 1].x === undefined) {\n      result[result.length - 1].x = 1;\n    }\n\n    // 3. If any control point has an input progress value that is less\n    // than the input progress value of any preceding control point, set\n    // its input progress value to the largest input progress value of\n    // any preceding control point.\n    let maxPrecedingX = 0;\n    for (let i = 1; i < result.length - 1; i++) {\n      const x = result[i].x;\n      if (x !== undefined) {\n        if (x < maxPrecedingX) {\n          logger.warn(\n            WARN_MESSAGES.inputProgressLessThanPrecedingPoint(x, maxPrecedingX)\n          );\n          result[i].x = maxPrecedingX;\n        } else {\n          maxPrecedingX = x;\n        }\n      }\n    }\n\n    // 4. If any control point still lacks an input progress value, then\n    // for each contiguous run of such control points, set their input\n    // progress values so that they are evenly spaced between the preceding\n    // and following control points with input progress values.\n    let precedingX = result[0].x;\n    let missingCount = 0;\n    for (let i = 1; i < result.length; i++) {\n      const x = result[i].x;\n\n      if (x === undefined) {\n        missingCount++;\n        continue;\n      }\n\n      if (missingCount > 0) {\n        const range = x - precedingX;\n\n        for (let j = 0; j < missingCount; j++) {\n          result[i - missingCount + j].x =\n            precedingX + (range * (j + 1)) / (missingCount + 1);\n        }\n      }\n\n      precedingX = x;\n      missingCount = 0;\n    }\n\n    return result as Point[];\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}