{"ast":null,"code":"'use strict';\n\nvar _jsxFileName = \"C:\\\\Users\\\\prana\\\\OneDrive\\\\Desktop\\\\civic-reporter-sih\\\\frontend\\\\node_modules\\\\react-native-reanimated\\\\lib\\\\module\\\\css\\\\component\\\\AnimatedComponent.js\";\nimport { Component } from 'react';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport { IS_JEST, ReanimatedError, SHOULD_BE_USE_WEB } from \"../../common/index.js\";\nimport { getViewInfo } from \"../../createAnimatedComponent/getViewInfo.js\";\nimport { getShadowNodeWrapperFromRef } from '../../fabricUtils';\nimport { findHostInstance } from '../../platform-specific/findHostInstance';\nimport { markNodeAsRemovable, unmarkNodeAsRemovable } from \"../native/index.js\";\nimport { CSSManager } from '../platform';\nimport { filterNonCSSStyleProps } from \"./utils.js\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default class AnimatedComponent extends Component {\n  _cssStyle = {};\n  _componentRef = null;\n  _hasAnimatedRef = false;\n  _componentDOMRef = null;\n  _willUnmount = false;\n  constructor(ChildComponent, props) {\n    super(props);\n    this.ChildComponent = ChildComponent;\n  }\n  getComponentViewTag() {\n    return this._getViewInfo().viewTag;\n  }\n  _onSetLocalRef() {}\n  _getViewInfo() {\n    if (this._viewInfo !== undefined) {\n      return this._viewInfo;\n    }\n    let viewTag;\n    let shadowNodeWrapper = null;\n    let DOMElement = null;\n    let viewName;\n    if (SHOULD_BE_USE_WEB) {\n      viewTag = this._componentRef;\n      DOMElement = this._componentDOMRef;\n    } else {\n      const hostInstance = findHostInstance(this);\n      if (!hostInstance) {\n        throw new ReanimatedError('Cannot find host instance for this component. Maybe it renders nothing?');\n      }\n      const viewInfo = getViewInfo(hostInstance);\n      viewTag = viewInfo.viewTag ?? -1;\n      viewName = viewInfo.viewName;\n      shadowNodeWrapper = getShadowNodeWrapperFromRef(this, hostInstance);\n    }\n    this._viewInfo = {\n      viewTag,\n      shadowNodeWrapper,\n      viewName\n    };\n    if (DOMElement) {\n      this._viewInfo.DOMElement = DOMElement;\n    }\n    return this._viewInfo;\n  }\n  _setComponentRef = ref => {\n    const forwardedRef = this.props.forwardedRef;\n    if (typeof forwardedRef === 'function') {\n      forwardedRef(ref);\n    } else if (typeof forwardedRef === 'object' && forwardedRef) {\n      forwardedRef.current = ref;\n    }\n    if (!ref) {\n      return;\n    }\n    if (ref !== this._componentRef) {\n      this._componentRef = this._resolveComponentRef(ref);\n      this._viewInfo = undefined;\n    }\n    this._onSetLocalRef();\n  };\n  _resolveComponentRef = ref => {\n    const componentRef = ref;\n    if (componentRef && componentRef.getAnimatableRef) {\n      this._hasAnimatedRef = true;\n      return componentRef.getAnimatableRef();\n    }\n    if (SHOULD_BE_USE_WEB) {\n      if (componentRef && componentRef.elementRef) {\n        this._componentDOMRef = componentRef.elementRef.current;\n      } else {\n        this._componentDOMRef = ref;\n      }\n    }\n    return componentRef;\n  };\n  _updateStyles(props) {\n    this._cssStyle = StyleSheet.flatten(props.style) ?? {};\n  }\n  componentDidMount() {\n    this._updateStyles(this.props);\n    const viewTag = this._viewInfo?.viewTag;\n    if (!SHOULD_BE_USE_WEB && this._willUnmount && typeof viewTag === 'number') {\n      unmarkNodeAsRemovable(viewTag);\n    }\n    if (!IS_JEST) {\n      this._CSSManager ??= new CSSManager(this._getViewInfo());\n      this._CSSManager?.update(this._cssStyle);\n    }\n    this._willUnmount = false;\n  }\n  componentWillUnmount() {\n    if (!IS_JEST && this._CSSManager) {\n      this._CSSManager.unmountCleanup();\n    }\n    const wrapper = this._viewInfo?.shadowNodeWrapper;\n    if (!SHOULD_BE_USE_WEB && wrapper) {\n      markNodeAsRemovable(wrapper);\n    }\n    this._willUnmount = true;\n  }\n  shouldComponentUpdate(nextProps) {\n    this._updateStyles(nextProps);\n    if (this._CSSManager) {\n      this._CSSManager.update(this._cssStyle);\n    }\n    return true;\n  }\n  render(props) {\n    const {\n      ChildComponent\n    } = this;\n    const platformProps = Platform.select({\n      web: {},\n      default: {\n        collapsable: false\n      }\n    });\n    return _jsxDEV(ChildComponent, Object.assign({}, props ?? this.props, platformProps, {\n      style: filterNonCSSStyleProps(props?.style ?? this.props.style),\n      ref: this._setComponentRef\n    }), void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 159,\n      columnNumber: 12\n    }, this);\n  }\n}","map":{"version":3,"names":["_jsxFileName","Component","Platform","StyleSheet","IS_JEST","ReanimatedError","SHOULD_BE_USE_WEB","getViewInfo","getShadowNodeWrapperFromRef","findHostInstance","markNodeAsRemovable","unmarkNodeAsRemovable","CSSManager","filterNonCSSStyleProps","jsxDEV","_jsxDEV","AnimatedComponent","_cssStyle","_componentRef","_hasAnimatedRef","_componentDOMRef","_willUnmount","constructor","ChildComponent","props","getComponentViewTag","_getViewInfo","viewTag","_onSetLocalRef","_viewInfo","undefined","shadowNodeWrapper","DOMElement","viewName","hostInstance","viewInfo","_setComponentRef","ref","forwardedRef","current","_resolveComponentRef","componentRef","getAnimatableRef","elementRef","_updateStyles","flatten","style","componentDidMount","_CSSManager","update","componentWillUnmount","unmountCleanup","wrapper","shouldComponentUpdate","nextProps","render","platformProps","select","web","default","collapsable","Object","assign","fileName","lineNumber","columnNumber"],"sources":["C:\\Users\\prana\\OneDrive\\Desktop\\civic-reporter-sih\\frontend\\node_modules\\react-native-reanimated\\src\\css\\component\\AnimatedComponent.tsx"],"sourcesContent":["'use strict';\nimport type { ComponentProps, Ref } from 'react';\nimport { Component } from 'react';\nimport type { StyleProp } from 'react-native';\nimport { Platform, StyleSheet } from 'react-native';\n\nimport { IS_JEST, ReanimatedError, SHOULD_BE_USE_WEB } from '../../common';\nimport type { ShadowNodeWrapper, WrapperRef } from '../../commonTypes';\nimport type {\n  AnimatedComponentRef,\n  IAnimatedComponentInternalBase,\n  ViewInfo,\n} from '../../createAnimatedComponent/commonTypes';\nimport { getViewInfo } from '../../createAnimatedComponent/getViewInfo';\nimport { getShadowNodeWrapperFromRef } from '../../fabricUtils';\nimport { findHostInstance } from '../../platform-specific/findHostInstance';\nimport { markNodeAsRemovable, unmarkNodeAsRemovable } from '../native';\nimport { CSSManager } from '../platform';\nimport type { AnyComponent, AnyRecord, CSSStyle, PlainStyle } from '../types';\nimport { filterNonCSSStyleProps } from './utils';\n\nexport type AnimatedComponentProps = Record<string, unknown> & {\n  ref?: Ref<Component>;\n  style?: StyleProp<PlainStyle>;\n};\n\n// TODO - change these ugly underscore prefixed methods and properties to real\n// private/protected ones when possible (when changes from this repo are merged\n// to the main one)\nexport default class AnimatedComponent<\n    P extends AnyRecord = AnimatedComponentProps,\n  >\n  extends Component<P>\n  implements IAnimatedComponentInternalBase\n{\n  ChildComponent: AnyComponent;\n\n  _CSSManager?: CSSManager;\n\n  _viewInfo?: ViewInfo;\n  _cssStyle: CSSStyle = {}; // RN style object with Reanimated CSS properties\n  _componentRef: AnimatedComponentRef | HTMLElement | null = null;\n  _hasAnimatedRef = false;\n  // Used only on web\n  _componentDOMRef: HTMLElement | null = null;\n  _willUnmount: boolean = false;\n\n  constructor(ChildComponent: AnyComponent, props: P) {\n    super(props);\n    this.ChildComponent = ChildComponent;\n  }\n\n  getComponentViewTag() {\n    return this._getViewInfo().viewTag as number;\n  }\n\n  _onSetLocalRef() {\n    // noop - can be overridden in subclasses\n  }\n\n  _getViewInfo(): ViewInfo {\n    if (this._viewInfo !== undefined) {\n      return this._viewInfo;\n    }\n\n    let viewTag: number | typeof this._componentRef;\n    let shadowNodeWrapper: ShadowNodeWrapper | null = null;\n    let DOMElement: HTMLElement | null = null;\n    let viewName: string | undefined;\n\n    if (SHOULD_BE_USE_WEB) {\n      // At this point we assume that `_setComponentRef` was already called and `_component` is set.\n      // `this._component` on web represents HTMLElement of our component, that's why we use casting\n      // TODO - implement a valid solution later on - this is a temporary fix\n      viewTag = this._componentRef;\n      DOMElement = this._componentDOMRef;\n    } else {\n      const hostInstance = findHostInstance(this);\n      if (!hostInstance) {\n        /* \n          findHostInstance can return null for a component that doesn't render anything \n          (render function returns null). Example: \n          svg Stop: https://github.com/react-native-svg/react-native-svg/blob/develop/src/elements/Stop.tsx\n        */\n        throw new ReanimatedError(\n          'Cannot find host instance for this component. Maybe it renders nothing?'\n        );\n      }\n\n      const viewInfo = getViewInfo(hostInstance);\n      viewTag = viewInfo.viewTag ?? -1;\n      viewName = viewInfo.viewName;\n      shadowNodeWrapper = getShadowNodeWrapperFromRef(\n        this as WrapperRef,\n        hostInstance\n      );\n    }\n    this._viewInfo = { viewTag, shadowNodeWrapper, viewName };\n    if (DOMElement) {\n      this._viewInfo.DOMElement = DOMElement;\n    }\n\n    return this._viewInfo;\n  }\n\n  _setComponentRef = (ref: Component | HTMLElement) => {\n    const forwardedRef = this.props.forwardedRef;\n    // Forward to user ref prop (if one has been specified)\n    if (typeof forwardedRef === 'function') {\n      // Handle function-based refs. String-based refs are handled as functions.\n      forwardedRef(ref);\n    } else if (typeof forwardedRef === 'object' && forwardedRef) {\n      // Handle createRef-based refs\n      forwardedRef.current = ref;\n    }\n\n    if (!ref) {\n      // component has been unmounted\n      return;\n    }\n    if (ref !== this._componentRef) {\n      this._componentRef = this._resolveComponentRef(ref);\n      // if ref is changed, reset viewInfo\n      this._viewInfo = undefined;\n    }\n    this._onSetLocalRef();\n  };\n\n  _resolveComponentRef = (ref: Component | HTMLElement | null) => {\n    const componentRef = ref as AnimatedComponentRef;\n    // Component can specify ref which should be animated when animated version of the component is created.\n    // Otherwise, we animate the component itself.\n    if (componentRef && componentRef.getAnimatableRef) {\n      this._hasAnimatedRef = true;\n      return componentRef.getAnimatableRef();\n    }\n    // Case for SVG components on Web\n    if (SHOULD_BE_USE_WEB) {\n      if (componentRef && componentRef.elementRef) {\n        this._componentDOMRef = componentRef.elementRef.current;\n      } else {\n        this._componentDOMRef = ref as HTMLElement;\n      }\n    }\n    return componentRef;\n  };\n\n  _updateStyles(props: P) {\n    this._cssStyle = StyleSheet.flatten(props.style) ?? {};\n  }\n\n  componentDidMount() {\n    this._updateStyles(this.props);\n\n    const viewTag = this._viewInfo?.viewTag;\n    if (\n      !SHOULD_BE_USE_WEB &&\n      this._willUnmount &&\n      typeof viewTag === 'number'\n    ) {\n      unmarkNodeAsRemovable(viewTag);\n    }\n\n    if (!IS_JEST) {\n      this._CSSManager ??= new CSSManager(this._getViewInfo());\n      this._CSSManager?.update(this._cssStyle);\n    }\n\n    this._willUnmount = false;\n  }\n\n  componentWillUnmount() {\n    if (!IS_JEST && this._CSSManager) {\n      this._CSSManager.unmountCleanup();\n    }\n\n    const wrapper = this._viewInfo?.shadowNodeWrapper;\n    if (!SHOULD_BE_USE_WEB && wrapper) {\n      // Mark node as removable on the native (C++) side, but only actually remove it\n      // when it no longer exists in the Shadow Tree. This ensures proper cleanup of\n      // animations/transitions/props while handling cases where the node might be\n      // remounted (e.g., when frozen) after componentWillUnmount is called.\n\n      markNodeAsRemovable(wrapper);\n    }\n\n    this._willUnmount = true;\n  }\n\n  shouldComponentUpdate(nextProps: P) {\n    this._updateStyles(nextProps);\n\n    if (this._CSSManager) {\n      this._CSSManager.update(this._cssStyle);\n    }\n\n    // TODO - maybe check if the render is necessary instead of always returning true\n    return true;\n  }\n\n  render(props?: ComponentProps<AnyComponent>) {\n    const { ChildComponent } = this;\n\n    const platformProps = Platform.select({\n      web: {},\n      default: { collapsable: false },\n    });\n\n    return (\n      <ChildComponent\n        {...(props ?? this.props)}\n        {...platformProps}\n        style={filterNonCSSStyleProps(props?.style ?? this.props.style)}\n        // Casting is used here, because ref can be null - in that case it cannot be assigned to HTMLElement.\n        // After spending some time trying to figure out what to do with this problem, we decided to leave it this way\n        ref={this._setComponentRef as (ref: Component) => void}\n      />\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}