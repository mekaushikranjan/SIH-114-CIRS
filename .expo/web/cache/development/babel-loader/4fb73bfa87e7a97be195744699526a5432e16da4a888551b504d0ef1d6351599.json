{"ast":null,"code":"import { useMemo } from 'react';\nimport resolveAssetSource from './resolveAssetSource';\nexport function useVideoPlayer(source, setup) {\n  const parsedSource = typeof source === 'string' ? {\n    uri: source\n  } : source;\n  return useMemo(() => {\n    const player = new VideoPlayerWeb(parsedSource);\n    setup?.(player);\n    return player;\n  }, [JSON.stringify(source)]);\n}\nexport function getSourceUri(source) {\n  if (typeof source === 'string') {\n    return source;\n  }\n  if (typeof source === 'number') {\n    return resolveAssetSource(source)?.uri ?? null;\n  }\n  if (typeof source?.assetId === 'number' && !source?.uri) {\n    return resolveAssetSource(source.assetId)?.uri ?? null;\n  }\n  return source?.uri ?? null;\n}\nexport function createVideoPlayer(source) {\n  const parsedSource = typeof source === 'string' ? {\n    uri: source\n  } : source;\n  return new VideoPlayerWeb(parsedSource);\n}\nexport default class VideoPlayerWeb extends globalThis.expo.SharedObject {\n  constructor(source) {\n    super();\n    this.src = source;\n  }\n  src = null;\n  previousSrc = null;\n  _mountedVideos = new Set();\n  _audioNodes = new Set();\n  playing = false;\n  _muted = false;\n  _volume = 1;\n  _loop = false;\n  _playbackRate = 1.0;\n  _preservesPitch = true;\n  _status = 'idle';\n  _error = null;\n  _timeUpdateLoop = null;\n  _timeUpdateEventInterval = 0;\n  audioMixingMode = 'auto';\n  allowsExternalPlayback = false;\n  staysActiveInBackground = false;\n  showNowPlayingNotification = false;\n  currentLiveTimestamp = null;\n  currentOffsetFromLive = null;\n  targetOffsetFromLive = 0;\n  bufferOptions = {};\n  subtitleTrack = null;\n  availableSubtitleTracks = [];\n  audioTrack = null;\n  availableAudioTracks = [];\n  videoTrack = null;\n  availableVideoTracks = [];\n  isExternalPlaybackActive = false;\n  keepScreenOnWhilePlaying = false;\n  set muted(value) {\n    this._mountedVideos.forEach(video => {\n      video.muted = value;\n    });\n    this._muted = value;\n  }\n  get muted() {\n    return this._muted;\n  }\n  set playbackRate(value) {\n    this._mountedVideos.forEach(video => {\n      video.playbackRate = value;\n    });\n    this._playbackRate = value;\n  }\n  get playbackRate() {\n    return this._playbackRate;\n  }\n  get isLive() {\n    return [...this._mountedVideos][0]?.duration === Infinity;\n  }\n  set volume(value) {\n    this._mountedVideos.forEach(video => {\n      video.volume = value;\n    });\n    this._volume = value;\n  }\n  get volume() {\n    return this._volume;\n  }\n  set loop(value) {\n    this._mountedVideos.forEach(video => {\n      video.loop = value;\n    });\n    this._loop = value;\n  }\n  get loop() {\n    return this._loop;\n  }\n  get currentTime() {\n    return [...this._mountedVideos][0]?.currentTime ?? 0;\n  }\n  set currentTime(value) {\n    this._mountedVideos.forEach(video => {\n      video.currentTime = value;\n    });\n  }\n  get duration() {\n    return [...this._mountedVideos][0]?.duration ?? 0;\n  }\n  get preservesPitch() {\n    return this._preservesPitch;\n  }\n  set preservesPitch(value) {\n    this._mountedVideos.forEach(video => {\n      video.preservesPitch = value;\n    });\n    this._preservesPitch = value;\n  }\n  get timeUpdateEventInterval() {\n    return this._timeUpdateEventInterval;\n  }\n  set timeUpdateEventInterval(value) {\n    this._timeUpdateEventInterval = value;\n    if (this._timeUpdateLoop) {\n      clearInterval(this._timeUpdateLoop);\n    }\n    if (value > 0) {\n      this.emit('timeUpdate', {\n        currentTime: this.currentTime,\n        currentLiveTimestamp: null,\n        currentOffsetFromLive: null,\n        bufferedPosition: this.bufferedPosition\n      });\n      this._timeUpdateLoop = setInterval(() => {\n        this.emit('timeUpdate', {\n          currentTime: this.currentTime,\n          currentLiveTimestamp: null,\n          currentOffsetFromLive: null,\n          bufferedPosition: this.bufferedPosition\n        });\n      }, value * 1000);\n    }\n  }\n  get status() {\n    return this._status;\n  }\n  get bufferedPosition() {\n    if (this._mountedVideos.size === 0 || this.status === 'error') {\n      return -1;\n    }\n    const buffered = [...this._mountedVideos][0]?.buffered;\n    for (let i = 0; i < buffered.length; i++) {\n      if (buffered.start(i) <= this.currentTime && buffered.end(i) >= this.currentTime) {\n        return buffered.end(i);\n      }\n    }\n    return 0;\n  }\n  set status(value) {\n    if (this._status === value) return;\n    if (value === 'error' && this._error) {\n      this.emit('statusChange', {\n        status: value,\n        oldStatus: this._status,\n        error: this._error\n      });\n    } else {\n      this.emit('statusChange', {\n        status: value,\n        oldStatus: this._status\n      });\n      this._error = null;\n    }\n    this._status = value;\n  }\n  mountVideoView(video) {\n    if (this._mountedVideos.size === 0) {\n      video.preservesPitch = this._preservesPitch;\n      video.loop = this._loop;\n      video.volume = this._volume;\n      video.muted = this._muted;\n      video.playbackRate = this._playbackRate;\n    }\n    this._mountedVideos.add(video);\n    this._addListeners(video);\n    this._synchronizeWithFirstVideo(video);\n  }\n  unmountVideoView(video) {\n    this._mountedVideos.delete(video);\n  }\n  mountAudioNode(audioContext, zeroGainNode, audioSourceNode) {\n    if (!audioContext || !zeroGainNode) return;\n    this._audioNodes.add(audioSourceNode);\n    if (this._audioNodes.size === 1) {\n      audioSourceNode.connect(audioContext.destination);\n    } else {\n      audioSourceNode.connect(zeroGainNode);\n    }\n  }\n  unmountAudioNode(video, audioContext, audioSourceNode) {\n    const mountedVideos = [...this._mountedVideos];\n    const videoPlayingAudio = mountedVideos[0];\n    this._audioNodes.delete(audioSourceNode);\n    audioSourceNode.disconnect();\n    if (videoPlayingAudio === video && this._audioNodes.size > 0 && audioContext) {\n      const newMainAudioSource = [...this._audioNodes][0];\n      newMainAudioSource.disconnect();\n      newMainAudioSource.connect(audioContext.destination);\n    }\n  }\n  play() {\n    this._mountedVideos.forEach(video => {\n      video.play();\n    });\n  }\n  pause() {\n    this._mountedVideos.forEach(video => {\n      video.pause();\n    });\n  }\n  replace(source) {\n    this._mountedVideos.forEach(video => {\n      const uri = getSourceUri(source);\n      video.pause();\n      if (uri) {\n        video.setAttribute('src', uri);\n        video.load();\n        video.play();\n      } else {\n        video.removeAttribute('src');\n        video.load();\n      }\n    });\n    this.previousSrc = this.src;\n    this.src = source;\n    this.playing = true;\n  }\n  async replaceAsync(source) {\n    return this.replace(source);\n  }\n  seekBy(seconds) {\n    this._mountedVideos.forEach(video => {\n      video.currentTime += seconds;\n    });\n  }\n  replay() {\n    this._mountedVideos.forEach(video => {\n      video.currentTime = 0;\n      video.play();\n    });\n    this.playing = true;\n  }\n  generateThumbnailsAsync(times) {\n    throw new Error('Generating video thumbnails is not supported on Web yet');\n  }\n  _synchronizeWithFirstVideo(video) {\n    const firstVideo = [...this._mountedVideos][0];\n    if (!firstVideo) return;\n    if (firstVideo.paused) {\n      video.pause();\n    } else {\n      video.play();\n    }\n    video.currentTime = firstVideo.currentTime;\n    video.volume = firstVideo.volume;\n    video.muted = firstVideo.muted;\n    video.playbackRate = firstVideo.playbackRate;\n  }\n  _emitOnce(eventSource, eventName, ...args) {\n    const mountedVideos = [...this._mountedVideos];\n    if (mountedVideos[0] === eventSource) {\n      this.emit(eventName, ...args);\n    }\n  }\n  _addListeners(video) {\n    video.onplay = () => {\n      this._emitOnce(video, 'playingChange', {\n        isPlaying: true,\n        oldIsPlaying: this.playing\n      });\n      this.playing = true;\n      this._mountedVideos.forEach(mountedVideo => {\n        mountedVideo.play();\n      });\n    };\n    video.onpause = () => {\n      this._emitOnce(video, 'playingChange', {\n        isPlaying: false,\n        oldIsPlaying: this.playing\n      });\n      this.playing = false;\n      this._mountedVideos.forEach(mountedVideo => {\n        mountedVideo.pause();\n      });\n    };\n    video.onvolumechange = () => {\n      this._emitOnce(video, 'volumeChange', {\n        volume: video.volume,\n        oldVolume: this.volume\n      });\n      this._emitOnce(video, 'mutedChange', {\n        muted: video.muted,\n        oldMuted: this.muted\n      });\n      this.volume = video.volume;\n      this.muted = video.muted;\n    };\n    video.onseeking = () => {\n      this._mountedVideos.forEach(mountedVideo => {\n        if (mountedVideo === video || mountedVideo.currentTime === video.currentTime) return;\n        mountedVideo.currentTime = video.currentTime;\n      });\n    };\n    video.onseeked = () => {\n      this._mountedVideos.forEach(mountedVideo => {\n        if (mountedVideo === video || mountedVideo.currentTime === video.currentTime) return;\n        mountedVideo.currentTime = video.currentTime;\n      });\n    };\n    video.onratechange = () => {\n      this._emitOnce(video, 'playbackRateChange', {\n        playbackRate: video.playbackRate,\n        oldPlaybackRate: this.playbackRate\n      });\n      this._mountedVideos.forEach(mountedVideo => {\n        if (mountedVideo.playbackRate === video.playbackRate) return;\n        this._playbackRate = video.playbackRate;\n        mountedVideo.playbackRate = video.playbackRate;\n      });\n      this._playbackRate = video.playbackRate;\n    };\n    video.onerror = () => {\n      this._error = {\n        message: video.error?.message ?? 'Unknown player error'\n      };\n      this.status = 'error';\n    };\n    video.oncanplay = () => {\n      const allCanPlay = [...this._mountedVideos].reduce((previousValue, video) => {\n        return previousValue && video.readyState >= 3;\n      }, true);\n      if (!allCanPlay) return;\n      this.status = 'readyToPlay';\n    };\n    video.onwaiting = () => {\n      if (this._status === 'loading') return;\n      this.status = 'loading';\n    };\n    video.onended = () => {\n      this._emitOnce(video, 'playToEnd');\n    };\n    video.onloadstart = () => {\n      this._emitOnce(video, 'sourceChange', {\n        source: this.src,\n        oldSource: this.previousSrc\n      });\n    };\n  }\n}","map":{"version":3,"names":["useMemo","resolveAssetSource","useVideoPlayer","source","setup","parsedSource","uri","player","VideoPlayerWeb","JSON","stringify","getSourceUri","assetId","createVideoPlayer","globalThis","expo","SharedObject","constructor","src","previousSrc","_mountedVideos","Set","_audioNodes","playing","_muted","_volume","_loop","_playbackRate","_preservesPitch","_status","_error","_timeUpdateLoop","_timeUpdateEventInterval","audioMixingMode","allowsExternalPlayback","staysActiveInBackground","showNowPlayingNotification","currentLiveTimestamp","currentOffsetFromLive","targetOffsetFromLive","bufferOptions","subtitleTrack","availableSubtitleTracks","audioTrack","availableAudioTracks","videoTrack","availableVideoTracks","isExternalPlaybackActive","keepScreenOnWhilePlaying","muted","value","forEach","video","playbackRate","isLive","duration","Infinity","volume","loop","currentTime","preservesPitch","timeUpdateEventInterval","clearInterval","emit","bufferedPosition","setInterval","status","size","buffered","i","length","start","end","oldStatus","error","mountVideoView","add","_addListeners","_synchronizeWithFirstVideo","unmountVideoView","delete","mountAudioNode","audioContext","zeroGainNode","audioSourceNode","connect","destination","unmountAudioNode","mountedVideos","videoPlayingAudio","disconnect","newMainAudioSource","play","pause","replace","setAttribute","load","removeAttribute","replaceAsync","seekBy","seconds","replay","generateThumbnailsAsync","times","Error","firstVideo","paused","_emitOnce","eventSource","eventName","args","onplay","isPlaying","oldIsPlaying","mountedVideo","onpause","onvolumechange","oldVolume","oldMuted","onseeking","onseeked","onratechange","oldPlaybackRate","onerror","message","oncanplay","allCanPlay","reduce","previousValue","readyState","onwaiting","onended","onloadstart","oldSource"],"sources":["C:\\Users\\prana\\OneDrive\\Desktop\\civic-reporter-sih\\frontend\\node_modules\\expo-video\\src\\VideoPlayer.web.tsx"],"sourcesContent":["import { useMemo } from 'react';\n\nimport type {\n  BufferOptions,\n  PlayerError,\n  VideoPlayerStatus,\n  VideoSource,\n  VideoPlayer,\n  SubtitleTrack,\n  AudioMixingMode,\n  VideoTrack,\n  AudioTrack,\n} from './VideoPlayer.types';\nimport type { VideoPlayerEvents } from './VideoPlayerEvents.types';\nimport { VideoThumbnail } from './VideoThumbnail';\nimport resolveAssetSource from './resolveAssetSource';\n\nexport function useVideoPlayer(\n  source: VideoSource,\n  setup?: (player: VideoPlayer) => void\n): VideoPlayer {\n  const parsedSource = typeof source === 'string' ? { uri: source } : source;\n\n  return useMemo(() => {\n    const player = new VideoPlayerWeb(parsedSource);\n    setup?.(player);\n    return player;\n  }, [JSON.stringify(source)]);\n}\n\nexport function getSourceUri(source: VideoSource): string | null {\n  if (typeof source === 'string') {\n    return source;\n  }\n  if (typeof source === 'number') {\n    return resolveAssetSource(source)?.uri ?? null;\n  }\n  if (typeof source?.assetId === 'number' && !source?.uri) {\n    return resolveAssetSource(source.assetId)?.uri ?? null;\n  }\n\n  return source?.uri ?? null;\n}\n\nexport function createVideoPlayer(source: VideoSource): VideoPlayer {\n  const parsedSource = typeof source === 'string' ? { uri: source } : source;\n\n  return new VideoPlayerWeb(parsedSource);\n}\n\nexport default class VideoPlayerWeb\n  extends globalThis.expo.SharedObject<VideoPlayerEvents>\n  implements VideoPlayer\n{\n  constructor(source: VideoSource) {\n    super();\n    this.src = source;\n  }\n\n  src: VideoSource = null;\n  previousSrc: VideoSource = null;\n  _mountedVideos: Set<HTMLVideoElement> = new Set();\n  _audioNodes: Set<MediaElementAudioSourceNode> = new Set();\n  playing: boolean = false;\n  _muted: boolean = false;\n  _volume: number = 1;\n  _loop: boolean = false;\n  _playbackRate: number = 1.0;\n  _preservesPitch: boolean = true;\n  _status: VideoPlayerStatus = 'idle';\n  _error: PlayerError | null = null;\n  _timeUpdateLoop: number | null = null;\n  _timeUpdateEventInterval: number = 0;\n  audioMixingMode: AudioMixingMode = 'auto'; // Not supported on web. Dummy to match the interface.\n  allowsExternalPlayback: boolean = false; // Not supported on web. Dummy to match the interface.\n  staysActiveInBackground: boolean = false; // Not supported on web. Dummy to match the interface.\n  showNowPlayingNotification: boolean = false; // Not supported on web. Dummy to match the interface.\n  currentLiveTimestamp: number | null = null; // Not supported on web. Dummy to match the interface.\n  currentOffsetFromLive: number | null = null; // Not supported on web. Dummy to match the interface.\n  targetOffsetFromLive: number = 0; // Not supported on web. Dummy to match the interface.\n  bufferOptions: BufferOptions = {} as BufferOptions; // Not supported on web. Dummy to match the interface.\n  subtitleTrack: SubtitleTrack | null = null; // Embedded subtitles are not supported by the html web player. Dummy to match the interface.\n  availableSubtitleTracks: SubtitleTrack[] = []; // Embedded subtitles are not supported by the html web player. Dummy to match the interface.\n  audioTrack: AudioTrack | null = null; // Not supported on web. Dummy to match the interface.\n  availableAudioTracks: AudioTrack[] = []; // Not supported on web. Dummy to match the interface.\n  videoTrack: VideoTrack | null = null; // Not supported on web. Dummy to match the interface.\n  availableVideoTracks: VideoTrack[] = []; // Not supported on web. Dummy to match the interface.\n  isExternalPlaybackActive: boolean = false; // Not supported on web. Dummy to match the interface.\n  keepScreenOnWhilePlaying: boolean = false; // Not supported on web. Dummy to match the interface\n\n  set muted(value: boolean) {\n    this._mountedVideos.forEach((video) => {\n      video.muted = value;\n    });\n    this._muted = value;\n  }\n\n  get muted(): boolean {\n    return this._muted;\n  }\n\n  set playbackRate(value: number) {\n    this._mountedVideos.forEach((video) => {\n      video.playbackRate = value;\n    });\n    this._playbackRate = value;\n  }\n\n  get playbackRate(): number {\n    return this._playbackRate;\n  }\n\n  get isLive(): boolean {\n    return [...this._mountedVideos][0]?.duration === Infinity;\n  }\n\n  set volume(value: number) {\n    this._mountedVideos.forEach((video) => {\n      video.volume = value;\n    });\n    this._volume = value;\n  }\n\n  get volume(): number {\n    return this._volume;\n  }\n\n  set loop(value: boolean) {\n    this._mountedVideos.forEach((video) => {\n      video.loop = value;\n    });\n    this._loop = value;\n  }\n\n  get loop(): boolean {\n    return this._loop;\n  }\n\n  get currentTime(): number {\n    // All videos should be synchronized, so we return the position of the first video.\n    return [...this._mountedVideos][0]?.currentTime ?? 0;\n  }\n\n  set currentTime(value: number) {\n    this._mountedVideos.forEach((video) => {\n      video.currentTime = value;\n    });\n  }\n\n  get duration(): number {\n    // All videos should have the same duration, so we return the duration of the first video.\n    return [...this._mountedVideos][0]?.duration ?? 0;\n  }\n\n  get preservesPitch(): boolean {\n    return this._preservesPitch;\n  }\n\n  set preservesPitch(value: boolean) {\n    this._mountedVideos.forEach((video) => {\n      video.preservesPitch = value;\n    });\n    this._preservesPitch = value;\n  }\n\n  get timeUpdateEventInterval(): number {\n    return this._timeUpdateEventInterval;\n  }\n  set timeUpdateEventInterval(value: number) {\n    this._timeUpdateEventInterval = value;\n    if (this._timeUpdateLoop) {\n      clearInterval(this._timeUpdateLoop);\n    }\n    if (value > 0) {\n      // Emit the first event immediately like on other platforms\n      this.emit('timeUpdate', {\n        currentTime: this.currentTime,\n        currentLiveTimestamp: null,\n        currentOffsetFromLive: null,\n        bufferedPosition: this.bufferedPosition,\n      });\n\n      this._timeUpdateLoop = setInterval(() => {\n        this.emit('timeUpdate', {\n          currentTime: this.currentTime,\n          currentLiveTimestamp: null,\n          currentOffsetFromLive: null,\n          bufferedPosition: this.bufferedPosition,\n        });\n      }, value * 1000);\n    }\n  }\n\n  get status(): VideoPlayerStatus {\n    return this._status;\n  }\n\n  get bufferedPosition(): number {\n    if (this._mountedVideos.size === 0 || this.status === 'error') {\n      return -1;\n    }\n    const buffered = [...this._mountedVideos][0]?.buffered;\n    for (let i = 0; i < buffered.length; i++) {\n      if (buffered.start(i) <= this.currentTime && buffered.end(i) >= this.currentTime) {\n        return buffered.end(i);\n      }\n    }\n    return 0;\n  }\n\n  private set status(value: VideoPlayerStatus) {\n    if (this._status === value) return;\n\n    if (value === 'error' && this._error) {\n      this.emit('statusChange', {\n        status: value,\n        oldStatus: this._status,\n        error: this._error,\n      });\n    } else {\n      this.emit('statusChange', {\n        status: value,\n        oldStatus: this._status,\n      });\n      this._error = null;\n    }\n    this._status = value;\n  }\n\n  mountVideoView(video: HTMLVideoElement) {\n    // The video will be the first video, it should inherit the properties set in the setup() function\n    if (this._mountedVideos.size === 0) {\n      video.preservesPitch = this._preservesPitch;\n      video.loop = this._loop;\n      video.volume = this._volume;\n      video.muted = this._muted;\n      video.playbackRate = this._playbackRate;\n    }\n    this._mountedVideos.add(video);\n    this._addListeners(video);\n    this._synchronizeWithFirstVideo(video);\n  }\n\n  unmountVideoView(video: HTMLVideoElement) {\n    this._mountedVideos.delete(video);\n  }\n\n  mountAudioNode(\n    audioContext: AudioContext,\n    zeroGainNode: GainNode,\n    audioSourceNode: MediaElementAudioSourceNode\n  ): void {\n    if (!audioContext || !zeroGainNode) return;\n\n    this._audioNodes.add(audioSourceNode);\n    // First mounted video should be connected to the audio context. All other videos have to be muted.\n    if (this._audioNodes.size === 1) {\n      audioSourceNode.connect(audioContext.destination);\n    } else {\n      audioSourceNode.connect(zeroGainNode);\n    }\n  }\n\n  unmountAudioNode(\n    video: HTMLVideoElement,\n    audioContext: AudioContext,\n    audioSourceNode: MediaElementAudioSourceNode\n  ) {\n    const mountedVideos = [...this._mountedVideos];\n    const videoPlayingAudio = mountedVideos[0];\n    this._audioNodes.delete(audioSourceNode);\n    audioSourceNode.disconnect();\n\n    // If video playing audio has been removed, select a new video to be the audio player by disconnecting it from the mute node.\n    if (videoPlayingAudio === video && this._audioNodes.size > 0 && audioContext) {\n      const newMainAudioSource = [...this._audioNodes][0];\n      newMainAudioSource.disconnect();\n      newMainAudioSource.connect(audioContext.destination);\n    }\n  }\n\n  play(): void {\n    this._mountedVideos.forEach((video) => {\n      video.play();\n    });\n  }\n\n  pause(): void {\n    this._mountedVideos.forEach((video) => {\n      video.pause();\n    });\n  }\n\n  replace(source: VideoSource): void {\n    this._mountedVideos.forEach((video) => {\n      const uri = getSourceUri(source);\n      video.pause();\n      if (uri) {\n        video.setAttribute('src', uri);\n        video.load();\n        video.play();\n      } else {\n        video.removeAttribute('src');\n        video.load();\n      }\n    });\n    // TODO @behenate: this won't work when we add support for playlists\n    this.previousSrc = this.src;\n    this.src = source;\n    this.playing = true;\n  }\n\n  // The HTML5 player already offloads loading of the asset onto a different thread so we can keep the same\n  // implementation until `replace` is deprecated and removed.\n  async replaceAsync(source: VideoSource): Promise<void> {\n    return this.replace(source);\n  }\n\n  seekBy(seconds: number): void {\n    this._mountedVideos.forEach((video) => {\n      video.currentTime += seconds;\n    });\n  }\n\n  replay(): void {\n    this._mountedVideos.forEach((video) => {\n      video.currentTime = 0;\n      video.play();\n    });\n    this.playing = true;\n  }\n\n  generateThumbnailsAsync(times: number | number[]): Promise<VideoThumbnail[]> {\n    throw new Error('Generating video thumbnails is not supported on Web yet');\n  }\n\n  _synchronizeWithFirstVideo(video: HTMLVideoElement): void {\n    const firstVideo = [...this._mountedVideos][0];\n    if (!firstVideo) return;\n\n    if (firstVideo.paused) {\n      video.pause();\n    } else {\n      video.play();\n    }\n    video.currentTime = firstVideo.currentTime;\n    video.volume = firstVideo.volume;\n    video.muted = firstVideo.muted;\n    video.playbackRate = firstVideo.playbackRate;\n  }\n\n  /**\n   * If there are multiple mounted videos, all of them will emit an event, as they are synchronised.\n   * We want to avoid this, so we only emit the event if it came from the first video.\n   */\n  _emitOnce<EventName extends keyof VideoPlayerEvents>(\n    eventSource: HTMLVideoElement,\n    eventName: EventName,\n    ...args: Parameters<VideoPlayerEvents[EventName]>\n  ): void {\n    const mountedVideos = [...this._mountedVideos];\n    if (mountedVideos[0] === eventSource) {\n      this.emit(eventName, ...args);\n    }\n  }\n\n  _addListeners(video: HTMLVideoElement): void {\n    video.onplay = () => {\n      this._emitOnce(video, 'playingChange', {\n        isPlaying: true,\n        oldIsPlaying: this.playing,\n      });\n      this.playing = true;\n      this._mountedVideos.forEach((mountedVideo) => {\n        mountedVideo.play();\n      });\n    };\n\n    video.onpause = () => {\n      this._emitOnce(video, 'playingChange', {\n        isPlaying: false,\n        oldIsPlaying: this.playing,\n      });\n      this.playing = false;\n      this._mountedVideos.forEach((mountedVideo) => {\n        mountedVideo.pause();\n      });\n    };\n\n    video.onvolumechange = () => {\n      this._emitOnce(video, 'volumeChange', { volume: video.volume, oldVolume: this.volume });\n      this._emitOnce(video, 'mutedChange', { muted: video.muted, oldMuted: this.muted });\n      this.volume = video.volume;\n      this.muted = video.muted;\n    };\n\n    video.onseeking = () => {\n      this._mountedVideos.forEach((mountedVideo) => {\n        if (mountedVideo === video || mountedVideo.currentTime === video.currentTime) return;\n        mountedVideo.currentTime = video.currentTime;\n      });\n    };\n\n    video.onseeked = () => {\n      this._mountedVideos.forEach((mountedVideo) => {\n        if (mountedVideo === video || mountedVideo.currentTime === video.currentTime) return;\n        mountedVideo.currentTime = video.currentTime;\n      });\n    };\n\n    video.onratechange = () => {\n      this._emitOnce(video, 'playbackRateChange', {\n        playbackRate: video.playbackRate,\n        oldPlaybackRate: this.playbackRate,\n      });\n      this._mountedVideos.forEach((mountedVideo) => {\n        if (mountedVideo.playbackRate === video.playbackRate) return;\n        this._playbackRate = video.playbackRate;\n        mountedVideo.playbackRate = video.playbackRate;\n      });\n      this._playbackRate = video.playbackRate;\n    };\n\n    video.onerror = () => {\n      this._error = {\n        message: video.error?.message ?? 'Unknown player error',\n      };\n      this.status = 'error';\n    };\n\n    video.oncanplay = () => {\n      const allCanPlay = [...this._mountedVideos].reduce((previousValue, video) => {\n        return previousValue && video.readyState >= 3;\n      }, true);\n      if (!allCanPlay) return;\n\n      this.status = 'readyToPlay';\n    };\n\n    video.onwaiting = () => {\n      if (this._status === 'loading') return;\n      this.status = 'loading';\n    };\n\n    video.onended = () => {\n      this._emitOnce(video, 'playToEnd');\n    };\n\n    video.onloadstart = () => {\n      this._emitOnce(video, 'sourceChange', { source: this.src, oldSource: this.previousSrc });\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}