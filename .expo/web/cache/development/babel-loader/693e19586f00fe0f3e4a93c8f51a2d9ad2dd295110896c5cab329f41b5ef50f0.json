{"ast":null,"code":"\"use strict\";\n\nimport VelocityTracker from './VelocityTracker';\nconst MAX_POINTERS = 20;\nexport default class PointerTracker {\n  velocityTracker = new VelocityTracker();\n  _trackedPointers = new Map();\n  touchEventsIds = new Map();\n  cachedAbsoluteAverages = {\n    x: 0,\n    y: 0\n  };\n  cachedRelativeAverages = {\n    x: 0,\n    y: 0\n  };\n  constructor() {\n    this.lastMovedPointerId = NaN;\n    for (let i = 0; i < MAX_POINTERS; ++i) {\n      this.touchEventsIds.set(i, NaN);\n    }\n  }\n  addToTracker(event) {\n    if (this.trackedPointers.has(event.pointerId)) {\n      return;\n    }\n    this.lastMovedPointerId = event.pointerId;\n    const newElement = {\n      abosoluteCoords: {\n        x: event.x,\n        y: event.y\n      },\n      relativeCoords: {\n        x: event.offsetX,\n        y: event.offsetY\n      },\n      timestamp: event.time,\n      velocityX: 0,\n      velocityY: 0\n    };\n    this.trackedPointers.set(event.pointerId, newElement);\n    this.mapTouchEventId(event.pointerId);\n    this.cachedAbsoluteAverages = this.getAbsoluteCoordsAverage();\n    this.cachedRelativeAverages = this.getRelativeCoordsAverage();\n  }\n  removeFromTracker(pointerId) {\n    this.trackedPointers.delete(pointerId);\n    this.removeMappedTouchId(pointerId);\n  }\n  track(event) {\n    const pointerData = this.trackedPointers.get(event.pointerId);\n    if (!pointerData) {\n      return;\n    }\n    this.lastMovedPointerId = event.pointerId;\n    this.velocityTracker.add(event);\n    const [velocityX, velocityY] = this.velocityTracker.velocity;\n    pointerData.velocityX = velocityX;\n    pointerData.velocityY = velocityY;\n    pointerData.abosoluteCoords = {\n      x: event.x,\n      y: event.y\n    };\n    pointerData.relativeCoords = {\n      x: event.offsetX,\n      y: event.offsetY\n    };\n    this.trackedPointers.set(event.pointerId, pointerData);\n    this.cachedAbsoluteAverages = this.getAbsoluteCoordsAverage();\n    this.cachedRelativeAverages = this.getRelativeCoordsAverage();\n  }\n  mapTouchEventId(id) {\n    for (const [mappedId, touchId] of this.touchEventsIds) {\n      if (isNaN(touchId)) {\n        this.touchEventsIds.set(mappedId, id);\n        break;\n      }\n    }\n  }\n  removeMappedTouchId(id) {\n    const mappedId = this.getMappedTouchEventId(id);\n    if (!isNaN(mappedId)) {\n      this.touchEventsIds.set(mappedId, NaN);\n    }\n  }\n  getMappedTouchEventId(touchEventId) {\n    for (const [key, value] of this.touchEventsIds.entries()) {\n      if (value === touchEventId) {\n        return key;\n      }\n    }\n    return NaN;\n  }\n  getVelocity(pointerId) {\n    const pointerData = this.trackedPointers.get(pointerId);\n    return pointerData ? {\n      x: pointerData.velocityX,\n      y: pointerData.velocityY\n    } : null;\n  }\n  getLastAbsoluteCoords(pointerId) {\n    return this.trackedPointers.get(pointerId ?? this.lastMovedPointerId)?.abosoluteCoords;\n  }\n  getLastRelativeCoords(pointerId) {\n    return this.trackedPointers.get(pointerId ?? this.lastMovedPointerId)?.relativeCoords;\n  }\n  getAbsoluteCoordsAverage() {\n    const coordsSum = this.getAbsoluteCoordsSum();\n    const avgX = coordsSum.x / this.trackedPointers.size;\n    const avgY = coordsSum.y / this.trackedPointers.size;\n    const averages = {\n      x: isNaN(avgX) ? this.cachedAbsoluteAverages.x : avgX,\n      y: isNaN(avgY) ? this.cachedAbsoluteAverages.y : avgY\n    };\n    return averages;\n  }\n  getRelativeCoordsAverage() {\n    const coordsSum = this.getRelativeCoordsSum();\n    const avgX = coordsSum.x / this.trackedPointers.size;\n    const avgY = coordsSum.y / this.trackedPointers.size;\n    const averages = {\n      x: isNaN(avgX) ? this.cachedRelativeAverages.x : avgX,\n      y: isNaN(avgY) ? this.cachedRelativeAverages.y : avgY\n    };\n    return averages;\n  }\n  getAbsoluteCoordsSum(ignoredPointer) {\n    const sum = {\n      x: 0,\n      y: 0\n    };\n    this.trackedPointers.forEach((value, key) => {\n      if (key !== ignoredPointer) {\n        sum.x += value.abosoluteCoords.x;\n        sum.y += value.abosoluteCoords.y;\n      }\n    });\n    return sum;\n  }\n  getRelativeCoordsSum(ignoredPointer) {\n    const sum = {\n      x: 0,\n      y: 0\n    };\n    this.trackedPointers.forEach((value, key) => {\n      if (key !== ignoredPointer) {\n        sum.x += value.relativeCoords.x;\n        sum.y += value.relativeCoords.y;\n      }\n    });\n    return sum;\n  }\n  resetTracker() {\n    this.velocityTracker.reset();\n    this.trackedPointers.clear();\n    this.lastMovedPointerId = NaN;\n    for (let i = 0; i < MAX_POINTERS; ++i) {\n      this.touchEventsIds.set(i, NaN);\n    }\n  }\n  static shareCommonPointers(stPointers, ndPointers) {\n    return stPointers.some(pointerId => ndPointers.includes(pointerId));\n  }\n  get trackedPointersCount() {\n    return this.trackedPointers.size;\n  }\n  get trackedPointersIDs() {\n    const keys = [];\n    this.trackedPointers.forEach((_value, key) => {\n      keys.push(key);\n    });\n    return keys;\n  }\n  get trackedPointers() {\n    return this._trackedPointers;\n  }\n}","map":{"version":3,"names":["VelocityTracker","MAX_POINTERS","PointerTracker","velocityTracker","_trackedPointers","Map","touchEventsIds","cachedAbsoluteAverages","x","y","cachedRelativeAverages","constructor","lastMovedPointerId","NaN","i","set","addToTracker","event","trackedPointers","has","pointerId","newElement","abosoluteCoords","relativeCoords","offsetX","offsetY","timestamp","time","velocityX","velocityY","mapTouchEventId","getAbsoluteCoordsAverage","getRelativeCoordsAverage","removeFromTracker","delete","removeMappedTouchId","track","pointerData","get","add","velocity","id","mappedId","touchId","isNaN","getMappedTouchEventId","touchEventId","key","value","entries","getVelocity","getLastAbsoluteCoords","getLastRelativeCoords","coordsSum","getAbsoluteCoordsSum","avgX","size","avgY","averages","getRelativeCoordsSum","ignoredPointer","sum","forEach","resetTracker","reset","clear","shareCommonPointers","stPointers","ndPointers","some","includes","trackedPointersCount","trackedPointersIDs","keys","_value","push"],"sources":["C:\\Users\\prana\\OneDrive\\Desktop\\civic-reporter-sih\\frontend\\node_modules\\react-native-gesture-handler\\src\\web\\tools\\PointerTracker.ts"],"sourcesContent":["import { AdaptedEvent, Point } from '../interfaces';\nimport VelocityTracker from './VelocityTracker';\n\nexport interface TrackerElement {\n  abosoluteCoords: Point;\n  relativeCoords: Point;\n  timestamp: number;\n  velocityX: number;\n  velocityY: number;\n}\n\nconst MAX_POINTERS = 20;\n\nexport default class PointerTracker {\n  private velocityTracker = new VelocityTracker();\n  private readonly _trackedPointers: Map<number, TrackerElement> = new Map<\n    number,\n    TrackerElement\n  >();\n\n  private touchEventsIds: Map<number, number> = new Map<number, number>();\n\n  private lastMovedPointerId: number;\n\n  private cachedAbsoluteAverages: Point = { x: 0, y: 0 };\n  private cachedRelativeAverages: Point = { x: 0, y: 0 };\n\n  public constructor() {\n    this.lastMovedPointerId = NaN;\n\n    for (let i = 0; i < MAX_POINTERS; ++i) {\n      this.touchEventsIds.set(i, NaN);\n    }\n  }\n\n  public addToTracker(event: AdaptedEvent): void {\n    if (this.trackedPointers.has(event.pointerId)) {\n      return;\n    }\n\n    this.lastMovedPointerId = event.pointerId;\n\n    const newElement: TrackerElement = {\n      abosoluteCoords: { x: event.x, y: event.y },\n      relativeCoords: { x: event.offsetX, y: event.offsetY },\n      timestamp: event.time,\n      velocityX: 0,\n      velocityY: 0,\n    };\n\n    this.trackedPointers.set(event.pointerId, newElement);\n    this.mapTouchEventId(event.pointerId);\n\n    this.cachedAbsoluteAverages = this.getAbsoluteCoordsAverage();\n    this.cachedRelativeAverages = this.getRelativeCoordsAverage();\n  }\n\n  public removeFromTracker(pointerId: number): void {\n    this.trackedPointers.delete(pointerId);\n    this.removeMappedTouchId(pointerId);\n  }\n\n  public track(event: AdaptedEvent): void {\n    const pointerData = this.trackedPointers.get(event.pointerId);\n\n    if (!pointerData) {\n      return;\n    }\n\n    this.lastMovedPointerId = event.pointerId;\n\n    this.velocityTracker.add(event);\n    const [velocityX, velocityY] = this.velocityTracker.velocity;\n\n    pointerData.velocityX = velocityX;\n    pointerData.velocityY = velocityY;\n\n    pointerData.abosoluteCoords = { x: event.x, y: event.y };\n    pointerData.relativeCoords = { x: event.offsetX, y: event.offsetY };\n\n    this.trackedPointers.set(event.pointerId, pointerData);\n\n    this.cachedAbsoluteAverages = this.getAbsoluteCoordsAverage();\n    this.cachedRelativeAverages = this.getRelativeCoordsAverage();\n  }\n\n  // Mapping TouchEvents ID\n  private mapTouchEventId(id: number): void {\n    for (const [mappedId, touchId] of this.touchEventsIds) {\n      if (isNaN(touchId)) {\n        this.touchEventsIds.set(mappedId, id);\n        break;\n      }\n    }\n  }\n\n  private removeMappedTouchId(id: number): void {\n    const mappedId: number = this.getMappedTouchEventId(id);\n    if (!isNaN(mappedId)) {\n      this.touchEventsIds.set(mappedId, NaN);\n    }\n  }\n\n  public getMappedTouchEventId(touchEventId: number): number {\n    for (const [key, value] of this.touchEventsIds.entries()) {\n      if (value === touchEventId) {\n        return key;\n      }\n    }\n\n    return NaN;\n  }\n\n  public getVelocity(pointerId: number) {\n    const pointerData = this.trackedPointers.get(pointerId);\n\n    return pointerData\n      ? {\n          x: pointerData.velocityX,\n          y: pointerData.velocityY,\n        }\n      : null;\n  }\n\n  public getLastAbsoluteCoords(pointerId?: number) {\n    return this.trackedPointers.get(pointerId ?? this.lastMovedPointerId)\n      ?.abosoluteCoords;\n  }\n\n  public getLastRelativeCoords(pointerId?: number) {\n    return this.trackedPointers.get(pointerId ?? this.lastMovedPointerId)\n      ?.relativeCoords;\n  }\n\n  // Some handlers use these methods to send average values in native event.\n  // This may happen when pointers have already been removed from tracker (i.e. pointerup event).\n  // In situation when NaN would be sent as a response, we return cached value.\n  // That prevents handlers from crashing\n\n  public getAbsoluteCoordsAverage() {\n    const coordsSum = this.getAbsoluteCoordsSum();\n\n    const avgX = coordsSum.x / this.trackedPointers.size;\n    const avgY = coordsSum.y / this.trackedPointers.size;\n\n    const averages = {\n      x: isNaN(avgX) ? this.cachedAbsoluteAverages.x : avgX,\n      y: isNaN(avgY) ? this.cachedAbsoluteAverages.y : avgY,\n    };\n\n    return averages;\n  }\n\n  public getRelativeCoordsAverage() {\n    const coordsSum = this.getRelativeCoordsSum();\n\n    const avgX = coordsSum.x / this.trackedPointers.size;\n    const avgY = coordsSum.y / this.trackedPointers.size;\n\n    const averages = {\n      x: isNaN(avgX) ? this.cachedRelativeAverages.x : avgX,\n      y: isNaN(avgY) ? this.cachedRelativeAverages.y : avgY,\n    };\n\n    return averages;\n  }\n\n  public getAbsoluteCoordsSum(ignoredPointer?: number) {\n    const sum = { x: 0, y: 0 };\n\n    this.trackedPointers.forEach((value, key) => {\n      if (key !== ignoredPointer) {\n        sum.x += value.abosoluteCoords.x;\n        sum.y += value.abosoluteCoords.y;\n      }\n    });\n\n    return sum;\n  }\n\n  public getRelativeCoordsSum(ignoredPointer?: number) {\n    const sum = { x: 0, y: 0 };\n\n    this.trackedPointers.forEach((value, key) => {\n      if (key !== ignoredPointer) {\n        sum.x += value.relativeCoords.x;\n        sum.y += value.relativeCoords.y;\n      }\n    });\n\n    return sum;\n  }\n\n  public resetTracker(): void {\n    this.velocityTracker.reset();\n    this.trackedPointers.clear();\n    this.lastMovedPointerId = NaN;\n\n    for (let i = 0; i < MAX_POINTERS; ++i) {\n      this.touchEventsIds.set(i, NaN);\n    }\n  }\n\n  public static shareCommonPointers(\n    stPointers: number[],\n    ndPointers: number[]\n  ): boolean {\n    return stPointers.some((pointerId) => ndPointers.includes(pointerId));\n  }\n\n  public get trackedPointersCount(): number {\n    return this.trackedPointers.size;\n  }\n\n  public get trackedPointersIDs() {\n    const keys: number[] = [];\n\n    this.trackedPointers.forEach((_value, key) => {\n      keys.push(key);\n    });\n\n    return keys;\n  }\n\n  public get trackedPointers() {\n    return this._trackedPointers;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}